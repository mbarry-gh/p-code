{"version":3,"sources":["webpack://pcode/webpack/universalModuleDefinition","webpack://pcode/webpack/bootstrap","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/globals.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/constants.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/module.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","webpack://pcode/./node_modules/automation-events/build/es5/bundle.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/read-only-map.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/interfaces/index.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/types/index.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/get-backup-native-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-delay-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-gain-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/window.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","webpack://pcode/./node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node-factory.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://pcode/./node_modules/automation-events/node_modules/@babel/runtime/helpers/createClass.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Debug.js","webpack://pcode/./node_modules/tone/build/esm/core/util/TypeCheck.js","webpack://pcode/./node_modules/tone/build/esm/core/context/AudioContext.js","webpack://pcode/./node_modules/tslib/tslib.es6.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/Ticker.js","webpack://pcode/./node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Defaults.js","webpack://pcode/./node_modules/tone/build/esm/core/Tone.js","webpack://pcode/./node_modules/tone/build/esm/version.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Math.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Timeline.js","webpack://pcode/./node_modules/tone/build/esm/core/context/ContextInitialization.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Emitter.js","webpack://pcode/./node_modules/tone/build/esm/core/context/BaseContext.js","webpack://pcode/./node_modules/tone/build/esm/core/context/Context.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Interface.js","webpack://pcode/./node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","webpack://pcode/./node_modules/tone/build/esm/core/context/OfflineContext.js","webpack://pcode/./node_modules/tone/build/esm/core/Global.js","webpack://pcode/./node_modules/tone/build/esm/core/context/DummyContext.js","webpack://pcode/./node_modules/tone/build/esm/core/type/Conversions.js","webpack://pcode/./node_modules/tone/build/esm/core/type/TimeBase.js","webpack://pcode/./node_modules/tone/build/esm/core/type/Time.js","webpack://pcode/./node_modules/tone/build/esm/core/type/Frequency.js","webpack://pcode/./node_modules/tone/build/esm/core/type/TransportTime.js","webpack://pcode/./node_modules/tone/build/esm/core/context/ToneWithContext.js","webpack://pcode/./node_modules/tone/build/esm/core/util/StateTimeline.js","webpack://pcode/./node_modules/tone/build/esm/core/context/Param.js","webpack://pcode/./node_modules/tone/build/esm/core/context/ToneAudioNode.js","webpack://pcode/./node_modules/tone/build/esm/core/context/Gain.js","webpack://pcode/./node_modules/tone/build/esm/source/OneShotSource.js","webpack://pcode/./node_modules/tone/build/esm/signal/ToneConstantSource.js","webpack://pcode/./node_modules/tone/build/esm/signal/Signal.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/TickParam.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/TickSignal.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/TickSource.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/Clock.js","webpack://pcode/./node_modules/tone/build/esm/core/util/TimelineValue.js","webpack://pcode/./node_modules/tone/build/esm/core/type/Ticks.js","webpack://pcode/./node_modules/tone/build/esm/core/util/IntervalTimeline.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/TransportEvent.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js","webpack://pcode/./node_modules/tone/build/esm/core/clock/Transport.js","webpack://pcode/./node_modules/tone/build/esm/component/channel/Volume.js","webpack://pcode/./node_modules/tone/build/esm/core/context/Destination.js","webpack://pcode/./node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Draw.js","webpack://pcode/./node_modules/tone/build/esm/source/Source.js","webpack://pcode/./node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","webpack://pcode/./node_modules/tone/build/esm/source/Noise.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/Oscillator.js","webpack://pcode/./node_modules/tone/build/esm/signal/SignalOperator.js","webpack://pcode/./node_modules/tone/build/esm/signal/WaveShaper.js","webpack://pcode/./node_modules/tone/build/esm/signal/AudioToGain.js","webpack://pcode/./node_modules/tone/build/esm/signal/Multiply.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/AMOscillator.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/FMOscillator.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/FatOscillator.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/PWMOscillator.js","webpack://pcode/./node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","webpack://pcode/./node_modules/tone/build/esm/core/util/Decorator.js","webpack://pcode/./node_modules/tone/build/esm/source/buffer/Player.js","webpack://pcode/./node_modules/tone/build/esm/component/envelope/Envelope.js","webpack://pcode/./node_modules/tone/build/esm/instrument/Instrument.js","webpack://pcode/./node_modules/tone/build/esm/instrument/Monophonic.js","webpack://pcode/./node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","webpack://pcode/./node_modules/tone/build/esm/instrument/Synth.js","webpack://pcode/./node_modules/tone/build/esm/instrument/MembraneSynth.js","webpack://pcode/./node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js","webpack://pcode/./node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js","webpack://pcode/./node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","webpack://pcode/./node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","webpack://pcode/./node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js","webpack://pcode/./node_modules/tone/build/esm/instrument/Sampler.js","webpack://pcode/./node_modules/tone/build/esm/event/ToneEvent.js","webpack://pcode/./node_modules/tone/build/esm/event/Loop.js","webpack://pcode/./node_modules/tone/build/esm/component/channel/Panner.js","webpack://pcode/./node_modules/tone/build/esm/effect/BitCrusher.worklet.js","webpack://pcode/./node_modules/tone/build/esm/component/channel/Solo.js","webpack://pcode/./node_modules/tone/build/esm/component/channel/PanVol.js","webpack://pcode/./node_modules/tone/build/esm/component/channel/Channel.js","webpack://pcode/./node_modules/tone/build/esm/core/context/Listener.js","webpack://pcode/./node_modules/tone/build/esm/index.js","webpack://pcode/./lib/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","assignNativeAudioNodeOptions","nativeAudioNode","options","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isOwnedByContext","nativeContext","context","assignNativeAudioNodeOption","option","undefined","assignNativeAudioNodeAudioParamValue","audioParam","getNativeAudioNode","audioNode","createInvalidStateError","DOMException","err","code","getAudioNodeConnections","getValueForKey","map","Error","createNotSupportedError","interceptConnections","original","interceptor","connect","disconnect","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","cacheTestResult","Map","window","nativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","getBackupNativeContext","createNativeAudioNode","createNativeAnalyserNode","getAudioNodeRenderer","renderInputsOfAudioNode","createAnalyserNodeRenderer","auxiliaryGainNodeStore","getNativeContext","audioParamAudioNodeStore","eventTargetConstructor","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","audioNodeConstructor","analyserNodeConstructor","audioBufferStore","nativeAudioBufferConstructor","convertNumberToUnsignedLong","Uint32Array","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","createNativeGainNode","addSilentConnection","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","renderInputsOfAudioParam","connectAudioParam","createNativeAudioBufferSourceNode","renderAutomation","createAudioBufferSourceNodeRenderer","createAudioParam","audioBufferSourceNodeConstructor","audioDestinationNodeConstructor","createNativeBiquadFilterNode","createBiquadFilterNodeRenderer","biquadFilterNodeConstructor","monitorConnections","wrapChannelMergerNode","createNativeChannelMergerNode","createChannelMergerNodeRenderer","channelMergerNodeConstructor","createNativeChannelSplitterNode","createChannelSplitterNodeRenderer","channelSplitterNodeConstructor","createNativeConstantSourceNodeFaker","createNativeConstantSourceNode","createConstantSourceNodeRenderer","constantSourceNodeConstructor","createNativeConvolverNodeFaker","createNativeConvolverNode","createConvolverNodeRenderer","convolverNodeConstructor","createNativeDelayNode","createDelayNodeRenderer","delayNodeConstructor","createNativeDynamicsCompressorNode","createDynamicsCompressorNodeRenderer","dynamicsCompressorNodeConstructor","createGainNodeRenderer","gainNodeConstructor","createNativeScriptProcessorNode","createNativeIIRFilterNodeFaker","renderNativeOfflineAudioContext","createIIRFilterNodeRenderer","createNativeIIRFilterNode","iIRFilterNodeConstructor","createAudioListener","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","createNativeOscillatorNode","createOscillatorNodeRenderer","oscillatorNodeConstructor","createConnectedNativeAudioBufferSourceNode","createNativeWaveShaperNodeFaker","createNativeWaveShaperNode","createNativePannerNodeFaker","createNativePannerNode","createPannerNodeRenderer","pannerNodeConstructor","createNativePeriodicWave","periodicWaveConstructor","nativeStereoPannerNodeFakerFactory","createNativeStereoPannerNode","createStereoPannerNodeRenderer","stereoPannerNodeConstructor","createWaveShaperNodeRenderer","waveShaperNodeConstructor","isSecureContext","exposeCurrentFrameAndCurrentTime","addAudioWorkletModule","isNativeContext","decodeAudioData","baseAudioContextConstructor","createNativeMediaElementAudioSourceNode","mediaElementAudioSourceNodeConstructor","createNativeMediaStreamAudioDestinationNode","mediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioSourceNode","mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","mediaStreamTrackAudioSourceNodeConstructor","audioContextConstructor","getUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","connectMultipleOutputs","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createNativeAudioWorkletNodeFaker","createNativeAudioWorkletNode","nativeAudioWorkletNodeConstructor","createAudioWorkletNodeRenderer","audioWorkletNodeConstructor","createNativeOfflineAudioContext","startRendering","offlineAudioContextConstructor","isAnyAudioContext","isAnyAudioNode","isAnyAudioParam","isAnyOfflineAudioContext","testPromiseSupport","uint32Array","promise","buffer","catch","createIndexSizeError","insertElementInSet","set","element","predicate","ignoreDuplicates","lmnt","add","setInternalStateToActive","has","forEach","eventListener","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","_automationEvents","_currenTime","_defaultValue","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","isPartOfACycle","getEventListenersOfAudioNode","setInternalStateToPassive","delete","isAudioNodeOutputConnection","outputConnection","isActiveAudioNode","isAudioNode","audioNodeOrAudioParam","nativeAudioNodeOrAudioParam","getAudioParamConnections","getNativeAudioParam","wrapEventListener","event","descriptor","defineProperties","currentTarget","handleEvent","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","start","when","offset","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","stop","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","output","input","fakeNativeDestinationAudioNode","inputs","disconnectNativeAudioNodeFromNativeAudioNode","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","channelData","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","createInvalidAccessError","overwriteAccessors","createGetter","createSetter","getPrototypeOf","getOwnPropertyDescriptor","isValidLatencyHint","latencyHint","ReadOnlyMap","parameters","_map","size","entries","callback","thisArg","keys","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","k","computeBufferSize","baseLatency","sampleRate","max","min","round","log2","createUnknownError","isDCCurve","curve","createAbortError","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNodeRenderer","activeInputs","numberOfInputs","Set","outputs","passiveInputs","renderer","createAddAudioParamConnections","audioParamConnectionsStore","audioParamRenderer","createAddSilentConnection","nativeGainNode","channelCount","channelCountMode","channelInterpretation","gain","destination","removeEventListener","addEventListener","createAddUnrenderedAudioWorkletNode","audioWorkletNode","DEFAULT_OPTIONS","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","createAnalyserNodeConstructor","audionNodeConstructor","mergedOptions","nativeAnalyserNode","super","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getByteTimeDomainData","getFloatFrequencyData","getFloatTimeDomainData","createAnalyserNodeRendererFactory","renderedNativeAnalyserNodes","proxy","nativeOfflineAudioContext","trace","renderedNativeAnalyserNode","Promise","resolve","async","createAnalyserNode","numberOfChannels","createAudioBufferConstructor","testNativeAudioBufferConstructorSupport","AudioBuffer","createBuffer","hasInstance","instance","loop","loopEnd","loopStart","playbackRate","createAudioBufferSourceNodeConstructor","nativeAudioBufferSourceNode","isOffline","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","wrappedListener","onended","nativeOnEnded","resetInternalStateToPassive","setTimeout","createAudioBufferSourceNodeRendererFactory","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioContextConstructor","nativeAudioContext","TypeError","_baseLatency","_nativeAudioContext","_state","state","revokeState","close","then","mediaElement","mediaStream","mediaStreamTrack","reject","resolvePromise","resume","suspend","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","nativeAudioDestinationNodePromise","render","createAudioDestinationNode","createAudioListenerFactory","nativeListener","listener","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","channelMergerNode","scriptProcessorNode","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","onaudioprocess","inputBuffer","orientation","some","setOrientation","positon","setPosition","createFakeAudioParams","createAudioParamFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","nativeAudioParam","maxValue","minValue","automationEventList","setValueAtTime","currentTime","cancelAndHoldAtTime","flush","previousLastEvent","Array","from","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","numberOfOutputs","outputChannelCount","parameterData","processorOptions","createChannelCount","createAudioWorkletNodeConstructor","sanitizedOptions","nodeNameToProcessorConstructorMap","processorConstructor","nativeAudioWorkletNode","nm","_nativeAudioWorkletNode","_onprocessorerror","_parameters","onprocessorerror","nativeOnProcessorError","port","createBaseAudioContextConstructor","_nativeContext","_audioWorklet","addModule","moduleURL","maxDelayTime","real","imag","constraints","disableNormalization","audioData","successCallback","errorCallback","Q","detune","frequency","createBiquadFilterNodeConstructor","nativeBiquadFilterNode","_Q","_detune","_frequency","_gain","log10","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createCacheTestResult","ongoingTests","testResults","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createChannelMergerNodeConstructor","createChannelMergerNodeRendererFactory","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createConnectAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConnectedNativeAudioBufferSourceNodeFactory","createConstantSourceNodeConstructor","createConstantSourceNodeRendererFactory","nativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","createConvertNumberToUnsignedLong","unit32Array","createConvolverNodeConstructor","nativeConvolverNode","_nativeConvolverNode","normalize","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createCreateNativeOfflineAudioContext","createDataCloneError","createDecrementCycleCounter","cycleCounters","count","cycleCounter","nativeDestinationAudioParam","delayTime","createDelayNodeConstructor","nativeDelayNode","_delayTime","createDelayNodeRendererFactory","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDeleteUnrenderedAudioWorkletNode","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","destinationOrOutput","attack","knee","ratio","release","threshold","createDynamicsCompressorNodeConstructor","nativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createEncodingError","createEvaluateSource","source","SyntaxError","head","document","script","createElement","blob","Blob","url","URL","createObjectURL","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","revokeObjectURL","message","src","lineno","colno","error","location","href","onload","appendChild","createEventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","dispatchEvent","createExposeCurrentFrameAndCurrentTime","fn","currentFrame","configurable","createFetchSource","response","fetch","ok","text","createGainNodeConstructor","createGainNodeRendererFactory","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGetAudioNodeRenderer","audioNodeConnections","createGetAudioParamRenderer","audioParamConnections","createGetBackupNativeContext","backupNativeContext","bckpNtveCntxt","createGetNativeContext","contextStore","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodes","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","ntvCntxt","partialOfflineAudioContext","renderedBuffer","filteredBuffer","filterFullBuffer","createIncrementCycleCounterFactory","createIsAnyAudioContext","anything","createIsAnyAudioNode","audioNodeStore","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createIsNativeAudioContext","createIsNativeAudioNode","AudioNode","createIsNativeAudioParam","AudioParam","createIsNativeContext","createIsNativeOfflineAudioContext","createIsSecureContext","createIsSupportedPromise","testAudioBufferCopyChannelMethodsSubarraySupport","testAudioContextCloseMethodSupport","testAudioContextDecodeAudioDataMethodTypeErrorSupport","testAudioContextOptionsSupport","testAudioNodeConnectMethodSupport","testAudioWorkletProcessorNoOutputsSupport","testChannelMergerNodeChannelCountSupport","testConstantSourceNodeAccurateSchedulingSupport","testConvolverNodeBufferReassignabilitySupport","testIsSecureContextSupport","testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","testStereoPannerNodeDefaultValueSupport","testTransferablesSupport","all","every","result","createMediaElementAudioSourceNodeConstructor","nativeMediaElementAudioSourceNode","_mediaElement","_nativeMediaElementAudioSourceNode","createMediaStreamAudioDestinationNodeConstructor","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","stream","createMediaStreamAudioSourceNodeConstructor","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","createMinimalAudioContextConstructor","createMinimalBaseAudioContextConstructor","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalOfflineAudioContextConstructor","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMonitorConnections","whenConnected","whenDisconnected","connections","wasDisconnected","connection","wasConnected","apply","clear","isDisconnected","createNativeAudioBufferConstructor","createNativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","gainNode","createNativeAudioNodeFactory","factoryFunction","createNativeAudioWorkletNodeConstructor","AudioWorkletNode","createNativeBiquadFilterNodeFactory","createBiquadFilter","createNativeChannelMergerNodeFactory","nativeChannelMergerNode","createChannelMerger","createNativeConstantSourceNodeFactory","createConstantSource","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","audioBufferSourceNode","nativeConstantSourceNodeFaker","args","createNativeConvolverNodeFactory","createConvolver","createNativeConvolverNodeFakerFactory","convolverNode","nativeConvolverNodeFaker","createNativeDelayNodeFactory","createDelay","createNativeDynamicsCompressorNodeFactory","createDynamicsCompressor","createNativeGainNodeFactory","createGain","createNativeIIRFilterNodeFactory","divide","a","b","denominator","evaluatePolynomial","coefficient","z","createNativeIIRFilterNodeFakerFactory","bufferSize","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","PI","cos","sin","sqrt","atan2","createNativeMediaElementAudioSourceNodeFactory","ntvDCntxt","createMediaElementSource","createNativeMediaStreamAudioDestinationNodeFactory","createMediaStreamDestination","createNativeMediaStreamAudioSourceNodeFactory","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamTrackAudioSourceNodeFactory","createMediaStreamTrackSource","kind","createNativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOscillatorNodeFactory","nativeOscillatorNode","createOscillator","periodicWave","setPeriodicWave","createNativePannerNodeFactory","nativePannerNode","createPanner","orientationX","createNativePannerNodeFakerFactory","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationY","orientationZ","panningModel","refDistance","rolloffFactor","pannerNode","SINGLE_CHANNEL_OPTIONS","inputGainNode","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","oversample","nativePannerNodeFaker","createNativePeriodicWaveFactory","wrappedImag","wrappedReal","createPeriodicWave","createNativeScriptProcessorNodeFactory","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","CURVE_SIZE","channelSplitterNode","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","pan","connectGraph","disconnectGraph","isConnected","createNativeWaveShaperNodeFactory","nativeWaveShaperNode","createWaveShaper","disconnectNativeAudioBufferSourceNode","createNativeWaveShaperNodeFakerFactory","negativeWaveShaperNode","positiveWaveShaperNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","createOfflineAudioContextConstructor","createOscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createPannerNodeConstructor","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeRendererFactory","renderedBufferPromise","renderedNativeGainNodeOrNativePannerNode","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","createPeriodicWaveConstructor","periodicWaveStore","PeriodicWave","createRenderAutomation","getAudioParamRenderer","replay","createRenderInputsOfAudioNode","nextTrace","filter","includes","reduce","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","createStartRendering","createStereoPannerNodeConstructor","_pan","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createTestAudioBufferConstructorSupport","createTestAudioBufferCopyChannelMethodsSubarraySupport","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","createBufferSource","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","offlineAudioContext","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport","createTestAudioContextCloseMethodSupport","audioContext","isAudioContextClosable","createTestAudioContextDecodeAudioDataMethodTypeErrorSupport","isPending","createTestAudioContextOptionsSupport","createTestAudioNodeConnectMethodSupport","isSupported","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","createTestAudioWorkletProcessorNoOutputsSupport","isCallingProcess","audioWorklet","onmessage","createTestChannelMergerNodeChannelCountSupport","createTestConstantSourceNodeAccurateSchedulingSupport","Number","POSITIVE_INFINITY","createTestConvolverNodeBufferReassignabilitySupport","createTestIsSecureContextSupport","createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","createTestOfflineAudioContextCurrentTimeSupport","createTestStereoPannerNodeDefaultValueSupport","stereoPanner","createWaveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWindow","createWrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","createWrapChannelMergerNode","monitorConnectionsFunction","arrayBuffer","ArrayBuffer","port1","port2","MessageChannel","data","postMessage","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","isAudioWorkletNode","deleteEventListenerOfAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","matchingElement","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","analyzer","dummy","ones","chnnlDt","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputConnections","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","eventListeners","isActive","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","createAudioNodeConstructor","addAudioNodeConnections","createIncrementCycleCounter","decrementCycleCounter","detectCycles","_context","_nativeAudioNode","returnValue","connectionsToDestination","filteredConnections","wrapAudioNodeDisconnectMethod","auxiliaryGainNodes","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","onmessageerror","cloneAudioWorkletNodeOptions","createNativeAudioWorkletNodeFakerFactory","sum","numberOfParameters","parameterDescriptors","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessor","nodeToProcessorMap","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","prmtrs","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","potentiallyEmptyInputs","activeSourceFlag","process","ErrorEvent","disconnectFakeGraph","connectFakeGraph","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","importStatements","sourceWithoutImportStatements","replace","match","unresolvedUrl","importStatementWithResolvedUrl","toString","join","verifyParameterDescriptors","isArray","verifyProcessorCtor","processorCtor","constructible","Proxy","isConstructible","createAddAudioWorkletModule","evaluateSource","fetchSource","ongoingRequests","resolvedRequests","credentials","absoluteUrl","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","evaluateAudioWorkletGlobalScope","_AWGS","trim","rslvdRqstsFCntxt","ngngRqstsFCntxt","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","createNativeAnalyserNodeFactory","createAnalyser","byteTimeDomainData","Uint8Array","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createNativeAudioBufferSourceNodeFactory","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","stopTime","actualStartTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","processBuffer","processedBuffer","getAudioWorkletProcessor","createAudioWorkletNodeRendererFactory","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","createDecodeAudioData","detachedArrayBuffers","anyContext","complete","detachArrayBuffer","fail","createDetectCycles","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","createIIRFilterNodeConstructor","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createNativeAudioWorkletNodeFactory","testClonabilityOfAudioWorkletNodeOptions","createNativeChannelSplitterNodeFactory","nativeChannelSplitterNode","createChannelSplitter","wrapChannelSplitterNode","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arr","_arr","_n","_d","_e","_s","_i","next","done","arrayLikeToArray","minLen","constructor","len","arr2","Constructor","_defineProperties","props","writable","protoProps","staticProps","assert","statement","assertRange","gte","lte","Infinity","assertContextRunning","warn","defaultLogger","console","isUndef","arg","isDefined","isNumber","isObject","isBoolean","isString","isNote","theWindow","hasAudioContext","__decorate","decorators","desc","arguments","Reflect","decorate","__awaiter","_arguments","P","generator","fulfilled","step","e","rejected","Ticker","updateInterval","_callback","_type","_updateInterval","_createClock","toFixed","blobUrl","worker","Worker","_worker","_timeout","_createTimeout","_createWorker","clearTimeout","terminate","interval","_disposeClock","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","debug","_wasDisposed","TONE_DEBUG_CLASS","log","version","GT","GTE","EQ","LT","abs","clamp","_timeline","getDefaults","memory","increasing","valueOf","lastValue","_search","diff","param","after","beginning","end","midPoint","nextEvent","lowerBound","upperBound","_iterate","dispose","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","split","eventName","_events","boundCallback","off","on","eventList","constr","_constants","_timeouts","_timeoutIds","_initialized","_workletModules","createAudioContext","_ticker","emit","clockSource","_timeoutLoop","_setLatencyHint","lookAhead","ctx","feedForward","initialize","_transport","_draw","createAudioWorkletNode","rawContext","promises","_latencyHint","hint","lookAheadValue","val","constant","now","firstEvent","peek","timeout","remove","intervalFn","readOnly","str","noOp","reverse","load","_buffer","getContext","loaded","_reversed","_reverse","doneLoading","downloads","isMultidimensional","channels","multiChannelArray","chanNum","fromArray","toArray","outputArray","numChannels","channelArray","ret","startSamples","endSamples","retBuffer","subarray","rev","matches","extensions","extension","ext","supportsType","baseUrl","endsWith","canPlayType","_currentTime","_duration","asynchronous","yieldEvery","workletsAreReady","_renderClock","dummyContext","_numberOfChannels","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_audioData","_name","_options","_url","_fn","_id","_interval","_val","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","units","defaultUnits","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","testNotations","power","closest","closestSeconds","notation","notationSeconds","quarterTime","quarters","measures","sixteenths","sixteenthString","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","intervals","transpose","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","defaultContext","attribute","member","_getPartialProperties","initial","_initial","setStateAtTime","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","_assertRange","getAfter","before","beforeValue","previous","getBefore","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","currentVal","rampTime","setRampPoint","exponentialApproachValueAtTime","scaling","startingValue","segTime","cancel","valueAtTime","sampleTime","exponentialRampTo","linearRampTo","previousEvent","subdivisions","forEachAfter","t0","v0","v1","t1","_internalChannels","node","nodeList","_isAudioNode","_getInternalNodes","_getChannelProperties","_setChannelProperties","outputNum","inputNum","toDestination","nodes","connectSeries","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","_gainNode","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","fadeInTime","_stopGain","cancelStop","fadeOutTime","targetRampTo","additionalTail","_stopSource","_source","_startGain","override","_constantSource","connectSignal","rampTo","signal","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","currentTick","getTicksAtTime","getTimeOfTick","tick","delta","sol1","sol2","getDurationOfTicks","computedDuration","startTicks","ticksToTime","timeToTicks","_tickOffset","setTicksAtTime","stopEvent","getLastState","tmpEvent","lastState","elapsedTicks","forEachBetween","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","lastStateEvent","forEachTickBetween","maxStartTime","nextTickTime","_lastUpdate","_boundLoop","_loop","_tickSource","pause","mixin","initialValue","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","forEachFrom","replacement","isLeftChild","left","right","_setRoot","_replaceNodeInParent","temp","getBalance","pivotNode","balance","_rotateLeft","_rotateRight","low","allNodes","traverse","searchAfter","high","_left","_right","height","point","_eventId","_once","once","_currentId","_nextId","_nextTick","_boundRestart","_restart","_createEvents","invoke","scheduleOnce","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","forEachAtTime","_addEvent","eventId","item","timeline","computedAfter","offsetTicks","timeSig","startPosition","endPosition","toNotation","toBarsBeatsSixteenths","remainingTicks","computedFreq","ratioSignal","syncedSignal","volume","_unmutedVolume","mute","_buffers","_loadingCount","urls","_bufferLoaded","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","draw","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","sched","schedule","_start","immediate","restart","getNextState","_stop","stateEvent","startOffset","unsync","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","generateWaveform","_oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncSignal","unsyncSignal","_periodicWaveCache","find","description","_phase","arrayA","arrayB","oscProps","isBasicType","cache","_getCachedPeriodicWave","wave","_getRealImaginary","partial","exec","fullPartials","v","periodicWaveSize","piFactor","twoPi","_inverseFFT","_shaper","mapping","setMap","normalized","oversampling","_norm","_mult","factor","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","modulationIndex","_widthGate","_thresh","width","_triangle","_oscillators","_spread","spread","_forEach","osc","sourceType","_scale","_pulse","modulationFrequency","carrierType","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc","blockTime","sType","mType","range","valueMap","propertyKey","newValue","timeRange","_activeSources","_onload","autostart","origDuration","_onSourceEnd","implicitEnd","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","direction","curveName","EnvelopeCurves","curveDef","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","velocity","currentValue","decayValue","decayStart","triggerAttack","triggerRelease","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","envelope","computedAttack","computedDecay","pitchDecay","octaves","hertz","maxNote","workletContext","addToWorklet","classOrFunction","registerProcessor","classDesc","processor","urlMap","mid","notes","midiFloat","remainder","difference","_findClosest","closestNote","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","scheduleRepeat","_tick","prob","variation","reschedulTime","lastEvent","_event","iterations","iters","_panner","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","_soloed","_noSolos","_solo","_panVol","muted","buses","bus","_getBus","sendKnob","saw","tri","square","noise","limitHigh","limitLow","pointer","tokens","isPlaying","doLoop","looper","lastEvaluateTime","currentVolume","loopContext","defaultVolume","comment","meta","enable","enableCommentSyntax","line","lineComment","block","blockComment","enableMetaSyntax","metaCode","internalLoop","info","el","stack","consume","repeat","isNaN","chars","unpack","repeatCounter","lex","parse","prevChar","hasNext","execute","reset"],"mappings":"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","file":"p-code.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pcode\"] = factory();\n\telse\n\t\troot[\"pcode\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 684);\n","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\n//# sourceMappingURL=/build/es2019/globals.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-options.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=/build/es2019/constants.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=/build/es2019/helpers/is-owned-by-context.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-option.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/assign-native-audio-node-audio-param-value.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-native-audio-node.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/invalid-state-error.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-node-connections.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=/build/es2019/helpers/get-value-for-key.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/not-supported-error.js.map","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=/build/es2019/helpers/intercept-connections.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=/build/es2019/guards/native-audio-node-faker.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeConvolverNodeFakerFactory } from './factories/native-convolver-node-faker-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioDestinationNodeFactory } from './factories/native-media-stream-audio-destination-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst auxiliaryGainNodeStore = new WeakMap();\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNodeFaker = createNativeConvolverNodeFakerFactory(createNativeAudioNode, createNativeGainNode, monitorConnections);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet());\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = isSecureContext\n    ? createAddAudioWorkletModule(createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, getNativeContext, new WeakMap(), new WeakMap(), \n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window)\n    : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener)\n    : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=/build/es2019/module.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2019/helpers/test-promise-support.js.map","export const createIndexSizeError = () => {\n    try {\n        return new DOMException('', 'IndexSizeError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 1;\n        err.name = 'IndexSizeError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/index-size-error.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/insert-element-in-set.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-active.js.map","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    _slicedToArray = _slicedToArray && Object.prototype.hasOwnProperty.call(_slicedToArray, 'default') ? _slicedToArray['default'] : _slicedToArray;\n    _classCallCheck = _classCallCheck && Object.prototype.hasOwnProperty.call(_classCallCheck, 'default') ? _classCallCheck['default'] : _classCallCheck;\n    _createClass = _createClass && Object.prototype.hasOwnProperty.call(_createClass, 'default') ? _createClass['default'] : _createClass;\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/is-part-of-a-cycle.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-passive.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=/build/es2019/guards/audio-node-output-connection.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=/build/es2019/helpers/is-active-audio-node.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2019/guards/audio-node.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2019/guards/native-audio-node.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-param-connections.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-native-audio-param.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-event-listener.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=/build/es2019/helpers/copy-from-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = typeof y === 'number' ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=/build/es2019/helpers/create-nested-arrays.js.map","export const createInvalidAccessError = () => {\n    try {\n        return new DOMException('', 'InvalidAccessError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 15;\n        err.name = 'InvalidAccessError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/invalid-access-error.js.map","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n    let prototype = Object.getPrototypeOf(object);\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n//# sourceMappingURL=/build/es2019/helpers/overwrite-accessors.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return (latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback')));\n};\n//# sourceMappingURL=/build/es2019/helpers/is-valid-latency-hint.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=/build/es2019/read-only-map.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/copy-to-channel.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=/build/es2019/helpers/filter-buffer.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=/build/es2019/helpers/compute-buffer-size.js.map","export const createUnknownError = () => {\n    try {\n        return new DOMException('', 'UnknownError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.name = 'UnknownError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/unknown-error.js.map","export const isDCCurve = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n    const length = curve.length;\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n//# sourceMappingURL=/build/es2019/helpers/is-dc-curve.js.map","export * from './analyser-node';\nexport * from './analyser-options';\nexport * from './audio-buffer';\nexport * from './audio-buffer-options';\nexport * from './audio-buffer-source-node';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-options';\nexport * from './audio-context';\nexport * from './audio-context-options';\nexport * from './audio-destination-node';\nexport * from './audio-listener';\nexport * from './audio-node';\nexport * from './audio-node-options';\nexport * from './audio-node-renderer';\nexport * from './audio-param';\nexport * from './audio-param-descriptor';\nexport * from './audio-param-renderer';\nexport * from './audio-scheduled-source-node';\nexport * from './audio-scheduled-source-node-event-map';\nexport * from './audio-worklet';\nexport * from './audio-worklet-node';\nexport * from './audio-worklet-node-event-map';\nexport * from './audio-worklet-node-options';\nexport * from './audio-worklet-processor';\nexport * from './audio-worklet-processor-constructor';\nexport * from './automation';\nexport * from './base-audio-context';\nexport * from './biquad-filter-node';\nexport * from './biquad-filter-options';\nexport * from './channel-merger-options';\nexport * from './channel-splitter-options';\nexport * from './common-audio-context';\nexport * from './common-offline-audio-context';\nexport * from './constant-source-node';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-options';\nexport * from './convolver-node';\nexport * from './convolver-options';\nexport * from './delay-node';\nexport * from './delay-options';\nexport * from './dynamics-compressor-node';\nexport * from './dynamics-compressor-options';\nexport * from './gain-node';\nexport * from './gain-options';\nexport * from './iir-filter-node';\nexport * from './iir-filter-options';\nexport * from './media-element-audio-source-node';\nexport * from './media-element-audio-source-options';\nexport * from './media-stream-audio-destination-node';\nexport * from './media-stream-audio-source-node';\nexport * from './media-stream-audio-source-options';\nexport * from './media-stream-track-audio-source-node';\nexport * from './media-stream-track-audio-source-options';\nexport * from './minimal-audio-context';\nexport * from './minimal-base-audio-context';\nexport * from './minimal-base-audio-context-event-map';\nexport * from './minimal-offline-audio-context';\nexport * from './native-audio-node-faker';\nexport * from './native-audio-worklet-node-faker';\nexport * from './native-constant-source-node-faker';\nexport * from './native-convolver-node-faker';\nexport * from './native-iir-filter-node-faker';\nexport * from './native-panner-node-faker';\nexport * from './native-stereo-panner-node-faker';\nexport * from './native-wave-shaper-node-faker';\nexport * from './offline-audio-completion-event';\nexport * from './offline-audio-context';\nexport * from './offline-audio-context-constructor';\nexport * from './offline-audio-context-options';\nexport * from './oscillator-node';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-options';\nexport * from './panner-node';\nexport * from './panner-options';\nexport * from './periodic-wave';\nexport * from './periodic-wave-constraints';\nexport * from './periodic-wave-options';\nexport * from './read-only-map';\nexport * from './stereo-panner-node';\nexport * from './stereo-panner-options';\nexport * from './wave-shaper-node';\nexport * from './wave-shaper-options';\nexport * from './worklet-options';\n//# sourceMappingURL=/build/es2019/interfaces/index.js.map","export * from './abort-error-factory';\nexport * from './active-input-connection';\nexport * from './add-audio-node-connections-factory';\nexport * from './add-audio-node-connections-function';\nexport * from './add-audio-param-connections-factory';\nexport * from './add-audio-param-connections-function';\nexport * from './add-audio-worklet-module-factory';\nexport * from './add-audio-worklet-module-function';\nexport * from './add-silent-connection-factory';\nexport * from './add-silent-connection-function';\nexport * from './add-unrendered-audio-worklet-node-factory';\nexport * from './add-unrendered-audio-worklet-node-function';\nexport * from './analyser-node-constructor';\nexport * from './analyser-node-constructor-factory';\nexport * from './analyser-node-renderer-factory';\nexport * from './analyser-node-renderer-factory-factory';\nexport * from './any-audio-buffer';\nexport * from './any-context';\nexport * from './audio-buffer-constructor';\nexport * from './audio-buffer-constructor-factory';\nexport * from './audio-buffer-source-node-constructor';\nexport * from './audio-buffer-source-node-constructor-factory';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-node-renderer-factory';\nexport * from './audio-buffer-source-node-renderer-factory-factory';\nexport * from './audio-buffer-store';\nexport * from './audio-context-constructor';\nexport * from './audio-context-constructor-factory';\nexport * from './audio-context-latency-category';\nexport * from './audio-context-state';\nexport * from './audio-destination-node-constructor';\nexport * from './audio-destination-node-constructor-factory';\nexport * from './audio-destination-node-renderer-factory';\nexport * from './audio-listener-factory';\nexport * from './audio-listener-factory-factory';\nexport * from './audio-node-connections';\nexport * from './audio-node-connections-store';\nexport * from './audio-node-constructor';\nexport * from './audio-node-constructor-factory';\nexport * from './audio-node-output-connection';\nexport * from './audio-node-renderer';\nexport * from './audio-node-store';\nexport * from './audio-param-audio-node-store';\nexport * from './audio-param-connections';\nexport * from './audio-param-connections-store';\nexport * from './audio-param-factory';\nexport * from './audio-param-factory-factory';\nexport * from './audio-param-map';\nexport * from './audio-param-output-connection';\nexport * from './audio-param-renderer-factory';\nexport * from './audio-param-store';\nexport * from './audio-worklet-node-constructor';\nexport * from './audio-worklet-node-constructor-factory';\nexport * from './audio-worklet-node-renderer-factory';\nexport * from './audio-worklet-node-renderer-factory-factory';\nexport * from './auxiliary-gain-node-store';\nexport * from './base-audio-context-constructor';\nexport * from './base-audio-context-constructor-factory';\nexport * from './biquad-filter-node-constructor';\nexport * from './biquad-filter-node-constructor-factory';\nexport * from './biquad-filter-node-renderer-factory';\nexport * from './biquad-filter-node-renderer-factory-factory';\nexport * from './biquad-filter-type';\nexport * from './channel-count-mode';\nexport * from './channel-interpretation';\nexport * from './channel-merger-node-constructor';\nexport * from './channel-merger-node-constructor-factory';\nexport * from './channel-merger-node-renderer-factory';\nexport * from './channel-merger-node-renderer-factory-factory';\nexport * from './channel-splitter-node-constructor';\nexport * from './channel-splitter-node-constructor-factory';\nexport * from './channel-splitter-node-renderer-factory';\nexport * from './channel-splitter-node-renderer-factory-factory';\nexport * from './cache-test-result-factory';\nexport * from './cache-test-result-function';\nexport * from './connect-audio-param-factory';\nexport * from './connect-audio-param-function';\nexport * from './connect-multiple-outputs-factory';\nexport * from './connect-multiple-outputs-function';\nexport * from './connect-native-audio-node-to-native-audio-node-function';\nexport * from './connected-native-audio-buffer-source-node-factory';\nexport * from './connected-native-audio-buffer-source-node-factory-factory';\nexport * from './constant-source-node-constructor';\nexport * from './constant-source-node-constructor-factory';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-node-renderer-factory';\nexport * from './constant-source-node-renderer-factory-factory';\nexport * from './constructor';\nexport * from './context';\nexport * from './context-store';\nexport * from './convert-number-to-unsigned-long-factory';\nexport * from './convert-number-to-unsigned-long-function';\nexport * from './convolver-node-constructor';\nexport * from './convolver-node-constructor-factory';\nexport * from './convolver-node-renderer-factory';\nexport * from './convolver-node-renderer-factory-factory';\nexport * from './create-native-offline-audio-context-factory';\nexport * from './create-native-offline-audio-context-function';\nexport * from './cycle-counters';\nexport * from './data-clone-error-factory';\nexport * from './decode-audio-data-factory';\nexport * from './decode-audio-data-function';\nexport * from './decode-error-callback';\nexport * from './decode-success-callback';\nexport * from './decrement-cycle-counter-factory';\nexport * from './decrement-cycle-counter-function';\nexport * from './delay-node-constructor';\nexport * from './delay-node-constructor-factory';\nexport * from './delay-node-renderer-factory';\nexport * from './delay-node-renderer-factory-factory';\nexport * from './delete-unrendered-audio-worklet-node-factory';\nexport * from './delete-unrendered-audio-worklet-node-function';\nexport * from './detect-cycles-factory';\nexport * from './detect-cycles-function';\nexport * from './disconnect-multiple-outputs-factory';\nexport * from './disconnect-multiple-outputs-function';\nexport * from './disconnect-native-audio-node-from-native-audio-node-function';\nexport * from './distance-model-type';\nexport * from './dynamics-compressor-node-constructor';\nexport * from './dynamics-compressor-node-constructor-factory';\nexport * from './dynamics-compressor-node-renderer-factory';\nexport * from './dynamics-compressor-node-renderer-factory-factory';\nexport * from './encoding-error-factory';\nexport * from './error-event-handler';\nexport * from './evaluate-audio-worklet-global-scope-function';\nexport * from './evaluate-source-factory';\nexport * from './evaluate-source-function';\nexport * from './event-handler';\nexport * from './event-target-constructor';\nexport * from './event-target-constructor-factory';\nexport * from './expose-current-frame-and-current-time-factory';\nexport * from './expose-current-frame-and-current-time-function';\nexport * from './fetch-source-factory';\nexport * from './fetch-source-function';\nexport * from './gain-node-constructor';\nexport * from './gain-node-constructor-factory';\nexport * from './gain-node-renderer-factory';\nexport * from './gain-node-renderer-factory-factory';\nexport * from './get-audio-node-connections-function';\nexport * from './get-audio-node-renderer-factory';\nexport * from './get-audio-node-renderer-function';\nexport * from './get-audio-param-connections-function';\nexport * from './get-audio-param-renderer-factory';\nexport * from './get-audio-param-renderer-function';\nexport * from './get-backup-native-context-factory';\nexport * from './get-backup-native-context-function';\nexport * from './get-native-audio-node-function';\nexport * from './get-native-audio-param-function';\nexport * from './get-native-context-function';\nexport * from './get-native-context-factory';\nexport * from './get-unrendered-audio-worklet-nodes-factory';\nexport * from './get-unrendered-audio-worklet-nodes-function';\nexport * from './get-value-for-key-function';\nexport * from './iir-filter-node-constructor';\nexport * from './iir-filter-node-constructor-factory';\nexport * from './iir-filter-node-renderer-factory';\nexport * from './iir-filter-node-renderer-factory-factory';\nexport * from './increment-cycle-counter-factory';\nexport * from './increment-cycle-counter-factory-factory';\nexport * from './increment-cycle-counter-function';\nexport * from './index-size-error-factory';\nexport * from './insert-element-in-set-function';\nexport * from './internal-state-event-listener';\nexport * from './invalid-access-error-factory';\nexport * from './invalid-state-error-factory';\nexport * from './is-active-audio-node-function';\nexport * from './is-any-audio-context-factory';\nexport * from './is-any-audio-context-function';\nexport * from './is-any-audio-node-factory';\nexport * from './is-any-audio-node-function';\nexport * from './is-any-audio-param-factory';\nexport * from './is-any-audio-param-function';\nexport * from './is-any-offline-audio-context-factory';\nexport * from './is-any-offline-audio-context-function';\nexport * from './is-dc-curve-function';\nexport * from './is-native-audio-context-factory';\nexport * from './is-native-audio-context-function';\nexport * from './is-native-audio-node-factory';\nexport * from './is-native-audio-node-function';\nexport * from './is-native-audio-param-factory';\nexport * from './is-native-audio-param-function';\nexport * from './is-native-context-factory';\nexport * from './is-native-context-function';\nexport * from './is-native-offline-audio-context-factory';\nexport * from './is-native-offline-audio-context-function';\nexport * from './is-part-of-a-cycle-function';\nexport * from './is-secure-context-factory';\nexport * from './is-supported-promise-factory';\nexport * from './media-element-audio-source-node-constructor';\nexport * from './media-element-audio-source-node-constructor-factory';\nexport * from './media-stream-audio-destination-node-constructor';\nexport * from './media-stream-audio-destination-node-constructor-factory';\nexport * from './media-stream-audio-source-node-constructor';\nexport * from './media-stream-audio-source-node-constructor-factory';\nexport * from './media-stream-track-audio-source-node-constructor';\nexport * from './media-stream-track-audio-source-node-constructor-factory';\nexport * from './minimal-audio-context-constructor';\nexport * from './minimal-audio-context-constructor-factory';\nexport * from './minimal-base-audio-context-constructor';\nexport * from './minimal-base-audio-context-constructor-factory';\nexport * from './minimal-offline-audio-context-constructor';\nexport * from './minimal-offline-audio-context-constructor-factory';\nexport * from './monitor-connections-factory';\nexport * from './monitor-connections-function';\nexport * from './native-analyser-node';\nexport * from './native-analyser-node-factory';\nexport * from './native-analyser-node-factory-factory';\nexport * from './native-audio-buffer';\nexport * from './native-audio-buffer-constructor';\nexport * from './native-audio-buffer-constructor-factory';\nexport * from './native-audio-buffer-source-node';\nexport * from './native-audio-buffer-source-node-factory';\nexport * from './native-audio-buffer-source-node-factory-factory';\nexport * from './native-audio-context';\nexport * from './native-audio-context-constructor';\nexport * from './native-audio-context-constructor-factory';\nexport * from './native-audio-destination-node';\nexport * from './native-audio-destination-node-factory';\nexport * from './native-audio-destination-node-factory-factory';\nexport * from './native-audio-listener';\nexport * from './native-audio-node';\nexport * from './native-audio-node-factory';\nexport * from './native-audio-node-factory-factory';\nexport * from './native-audio-param';\nexport * from './native-audio-param-map';\nexport * from './native-audio-worklet';\nexport * from './native-audio-worklet-node';\nexport * from './native-audio-worklet-node-constructor';\nexport * from './native-audio-worklet-node-constructor-factory';\nexport * from './native-audio-worklet-node-factory';\nexport * from './native-audio-worklet-node-factory-factory';\nexport * from './native-audio-worklet-node-faker-factory';\nexport * from './native-audio-worklet-node-faker-factory-factory';\nexport * from './native-audio-worklet-node-options';\nexport * from './native-biquad-filter-node';\nexport * from './native-biquad-filter-node-factory';\nexport * from './native-biquad-filter-node-factory-factory';\nexport * from './native-channel-merger-node';\nexport * from './native-channel-merger-node-factory';\nexport * from './native-channel-merger-node-factory-factory';\nexport * from './native-channel-splitter-node';\nexport * from './native-channel-splitter-node-factory';\nexport * from './native-channel-splitter-node-factory-factory';\nexport * from './native-constant-source-node';\nexport * from './native-constant-source-node-factory';\nexport * from './native-constant-source-node-factory-factory';\nexport * from './native-constant-source-node-faker-factory';\nexport * from './native-constant-source-node-faker-factory-factory';\nexport * from './native-context';\nexport * from './native-convolver-node';\nexport * from './native-convolver-node-factory';\nexport * from './native-convolver-node-factory-factory';\nexport * from './native-convolver-node-faker-factory';\nexport * from './native-convolver-node-faker-factory-factory';\nexport * from './native-delay-node-factory';\nexport * from './native-delay-node-factory-factory';\nexport * from './native-delay-node';\nexport * from './native-dynamics-compressor-node';\nexport * from './native-dynamics-compressor-node-factory';\nexport * from './native-dynamics-compressor-node-factory-factory';\nexport * from './native-event-target';\nexport * from './native-gain-node';\nexport * from './native-gain-node-factory';\nexport * from './native-gain-node-factory-factory';\nexport * from './native-iir-filter-node';\nexport * from './native-iir-filter-node-factory';\nexport * from './native-iir-filter-node-factory-factory';\nexport * from './native-iir-filter-node-faker-factory';\nexport * from './native-iir-filter-node-faker-factory-factory';\nexport * from './native-media-element-audio-source-node';\nexport * from './native-media-element-audio-source-node-factory';\nexport * from './native-media-element-audio-source-node-factory-factory';\nexport * from './native-media-stream-audio-destination-node';\nexport * from './native-media-stream-audio-destination-node-factory';\nexport * from './native-media-stream-audio-destination-node-factory-factory';\nexport * from './native-media-stream-audio-source-node';\nexport * from './native-media-stream-audio-source-node-factory';\nexport * from './native-media-stream-audio-source-node-factory-factory';\nexport * from './native-media-stream-track-audio-source-node';\nexport * from './native-media-stream-track-audio-source-node-factory';\nexport * from './native-media-stream-track-audio-source-node-factory-factory';\nexport * from './native-offline-audio-context';\nexport * from './native-offline-audio-context-constructor';\nexport * from './native-offline-audio-context-constructor-factory';\nexport * from './native-oscillator-node';\nexport * from './native-oscillator-node-factory';\nexport * from './native-oscillator-node-factory-factory';\nexport * from './native-panner-node';\nexport * from './native-panner-node-factory';\nexport * from './native-panner-node-factory-factory';\nexport * from './native-panner-node-faker-factory';\nexport * from './native-panner-node-faker-factory-factory';\nexport * from './native-periodic-wave';\nexport * from './native-periodic-wave-factory';\nexport * from './native-periodic-wave-factory-factory';\nexport * from './native-script-processor-node';\nexport * from './native-script-processor-node-factory';\nexport * from './native-script-processor-node-factory-factory';\nexport * from './native-stereo-panner-node';\nexport * from './native-stereo-panner-node-factory';\nexport * from './native-stereo-panner-node-factory-factory';\nexport * from './native-stereo-panner-node-faker-factory';\nexport * from './native-stereo-panner-node-faker-factory-factory';\nexport * from './native-wave-shaper-node';\nexport * from './native-wave-shaper-node-factory';\nexport * from './native-wave-shaper-node-factory-factory';\nexport * from './native-wave-shaper-node-faker-factory';\nexport * from './native-wave-shaper-node-faker-factory-factory';\nexport * from './not-supported-error-factory';\nexport * from './offline-audio-context-constructor-factory';\nexport * from './oscillator-node-constructor';\nexport * from './oscillator-node-constructor-factory';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-node-renderer-factory';\nexport * from './oscillator-node-renderer-factory-factory';\nexport * from './oscillator-type';\nexport * from './output-connection';\nexport * from './over-sample-type';\nexport * from './overwrite-accessors-function';\nexport * from './panner-node-constructor';\nexport * from './panner-node-constructor-factory';\nexport * from './panner-node-renderer-factory';\nexport * from './panner-node-renderer-factory-factory';\nexport * from './panning-model-type';\nexport * from './passive-audio-node-input-connection';\nexport * from './passive-audio-param-input-connection';\nexport * from './periodic-wave-constructor';\nexport * from './periodic-wave-constructor-factory';\nexport * from './render-automation-factory';\nexport * from './render-automation-function';\nexport * from './render-inputs-of-audio-node-factory';\nexport * from './render-inputs-of-audio-node-function';\nexport * from './render-inputs-of-audio-param-factory';\nexport * from './render-inputs-of-audio-param-function';\nexport * from './render-native-offline-audio-context-factory';\nexport * from './render-native-offline-audio-context-function';\nexport * from './start-rendering-factory';\nexport * from './start-rendering-function';\nexport * from './stereo-panner-node-constructor';\nexport * from './stereo-panner-node-constructor-factory';\nexport * from './stereo-panner-node-renderer-factory-factory';\nexport * from './stereo-panner-node-renderer-factory';\nexport * from './test-audio-buffer-copy-channel-methods-subarray-support-factory';\nexport * from './test-audio-buffer-constructor-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-duration-parameter-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-offset-clamping-support-factory';\nexport * from './test-audio-buffer-source-node-stop-method-nullified-buffer-support-factory';\nexport * from './test-audio-context-close-method-support-factory';\nexport * from './test-audio-context-decode-audio-data-method-type-error-support-factory';\nexport * from './test-audio-context-options-support-factory';\nexport * from './test-audio-node-connect-method-support-factory';\nexport * from './test-audio-scheduled-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-negative-parameters-support-factory';\nexport * from './test-audio-worklet-processor-no-outputs-support-factory';\nexport * from './test-channel-merger-node-channel-count-support-factory';\nexport * from './test-constant-source-node-accurate-scheduling-support-factory';\nexport * from './test-convolver-node-buffer-reassignability-support-factory';\nexport * from './test-is-secure-context-support-factory';\nexport * from './test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nexport * from './test-offline-audio-context-current-time-support-factory';\nexport * from './test-stereo-panner-node-default-value-support-factory';\nexport * from './typed-array';\nexport * from './unknown-error-factory';\nexport * from './unrendered-audio-worklet-node-store';\nexport * from './unrendered-audio-worklet-nodes';\nexport * from './wave-shaper-node-constructor';\nexport * from './wave-shaper-node-constructor-factory';\nexport * from './wave-shaper-node-renderer-factory-factory';\nexport * from './wave-shaper-node-renderer-factory';\nexport * from './window-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-function';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-function';\nexport * from './wrap-audio-buffer-source-node-start-method-offset-clamping-function';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-function';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-factory';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function';\nexport * from './wrap-channel-merger-node-factory';\nexport * from './wrap-channel-merger-node-function';\nexport * from './wrap-event-listener-function';\n//# sourceMappingURL=/build/es2019/types/index.js.map","export const createAbortError = () => {\n    try {\n        return new DOMException('', 'AbortError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 20;\n        err.name = 'AbortError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/abort-error.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-node-connections.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-param-connections.js.map","export const createAddSilentConnection = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        nativeAudioScheduledSourceNode\n            .connect(nativeGainNode)\n            /*\n             * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n             * used here to make sure to connect the right destination.\n             */\n            .connect(nativeGainNode.context.destination);\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-silent-connection.js.map","export const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-unrendered-audio-worklet-node.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class AnalyserNode extends audionNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null));\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/analyser-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/analyser-node-renderer-factory.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline ? createAudioBufferSourceNodeRenderer() : null));\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = options.buffer !== null && options.buffer !== undefined;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err;\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer.getChannelData(i).fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-buffer-source-node-renderer-factory.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-context-constructor.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null));\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext, trace) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-destination-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: value\n                });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            // tslint:disable-next-line:deprecation\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => value !== lastPosition[index])) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-listener-factory.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? values[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-param-renderer.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: options.outputChannelCount !== undefined\n            ? options.outputChannelCount\n            : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                    [options.channelCount]\n                : createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-constructor.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                        addModule: (moduleURL, options) => {\n                            return addAudioWorkletModule(this, moduleURL, options);\n                        }\n                    };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class BiquadFilterNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = (isOffline ? createBiquadFilterNodeRenderer() : null);\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n            /*\n             * Bug #77: Edge does not export the correct values for maxValue and minValue. Firefox & Safari do not export the correct value\n             * for minValue.\n             */\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            // Bug #68: Only Chrome, Firefox & Opera do throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/biquad-filter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/biquad-filter-node-renderer-factory.js.map","export const createCacheTestResult = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        try {\n            const synchronousTestResult = test();\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                    ongoingTests.delete(tester);\n                    testResults.set(tester, finalTestResult);\n                    return finalTestResult;\n                });\n            }\n            testResults.set(tester, synchronousTestResult);\n            return synchronousTestResult;\n        }\n        catch {\n            testResults.set(tester, false);\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/cache-test-result.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelMergerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null));\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-merger-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-merger-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nconst sanitizedOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelSplitterNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null));\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-splitter-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/channel-splitter-node-renderer-factory.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connect-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connect-multiple-outputs.js.map","export const createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class ConstantSourceNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline ? createConstantSourceNodeRendererFactory() : null));\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/constant-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/constant-source-node-renderer-factory.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convert-number-to-unsigned-long.js.map","const DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ConvolverNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = (isOffline ? createConvolverNodeRenderer() : null);\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n            }\n            else {\n                this._isBufferNullified = false;\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convolver-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n            }\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/convolver-node-renderer-factory.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n            // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n            if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/create-native-offline-audio-context.js.map","export const createDataCloneError = () => {\n    try {\n        return new DOMException('', 'DataCloneError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 25;\n        err.name = 'DataCloneError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/data-clone-error.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/decrement-cycle-counter.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class DelayNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = (isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n            // Bug #161: Edge does not export the correct values for maxValue and minValue.\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delay-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delay-node-renderer-factory.js.map","export const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/delete-unrendered-audio-worklet-node.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/disconnect-multiple-outputs.js.map","const DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext) => {\n    return class DynamicsCompressorNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = (isOffline ? createDynamicsCompressorNodeRenderer() : null);\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            // Bug #110: Edge does not export the correct values for maxValue and minValue.\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n        }\n        get attack() {\n            return this._attack;\n        }\n        /*\n         * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n         * to be overwritten here.\n         */\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/dynamics-compressor-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/dynamics-compressor-node-renderer-factory.js.map","export const createEncodingError = () => {\n    try {\n        return new DOMException('', 'EncodingError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 0;\n        err.name = 'EncodingError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2019/factories/encoding-error.js.map","export const createEvaluateSource = (window) => {\n    return (source) => new Promise((resolve, reject) => {\n        if (window === null) {\n            reject(new SyntaxError());\n            return;\n        }\n        const head = window.document.head;\n        if (head === null) {\n            reject(new SyntaxError());\n        }\n        else {\n            const script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/evaluate-source.js.map","export const createEventTargetConstructor = (wrapEventListener) => {\n    return class EventTarget {\n        constructor(_nativeEventTarget) {\n            this._nativeEventTarget = _nativeEventTarget;\n            this._listeners = new WeakMap();\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/event-target-constructor.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/expose-current-frame-and-current-time.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return response.text();\n            }\n        }\n        catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/fetch-source.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class GainNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = (isOffline ? createGainNodeRenderer() : null);\n            super(context, false, nativeGainNode, gainNodeRenderer);\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/gain-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/gain-node-renderer-factory.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-audio-node-renderer.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-audio-param-renderer.js.map","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        /*\n         * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n         * backupNativeContext in that case.\n         */\n        if (nativeContext.state === 'closed' &&\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                if (nativeOfflineAudioContextConstructor !== null) {\n                    // @todo Copy the attached AudioWorkletProcessors and other settings.\n                    const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n                    BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                    return bckpNtveCntxt;\n                }\n            }\n            else {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                // @todo Copy the attached AudioWorkletProcessors and other settings.\n                const bckpNtveCntxt = new nativeAudioContextConstructor();\n                BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                return bckpNtveCntxt;\n            }\n        }\n        return null;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-backup-native-context.js.map","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return (nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-native-context.js.map","export const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/get-unrendered-audio-worklet-nodes.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/iir-filter-node-renderer-factory.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/increment-cycle-counter-factory.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-any-offline-audio-context.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-context.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-audio-param.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-context.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/is-native-offline-audio-context.js.map","export const createIsSecureContext = (window) => window !== null && window.isSecureContext;\n//# sourceMappingURL=/build/es2019/factories/is-secure-context.js.map","export const createIsSupportedPromise = async (cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) => {\n    if (cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) &&\n        cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) &&\n        cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) &&\n        cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) &&\n        cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) &&\n        cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) &&\n        cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) &&\n        cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) &&\n        cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)) {\n        const results = await Promise.all([\n            cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport),\n            cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport),\n            cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport),\n            cacheTestResult(testTransferablesSupport, testTransferablesSupport)\n        ]);\n        return results.every((result) => result);\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2019/factories/is-supported-promise.js.map","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaElementAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n            super(context, true, nativeMediaElementAudioSourceNode, null);\n            // Bug #63: Edge does not expose the mediaElement yet.\n            this._mediaElement = options.mediaElement;\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return this._nativeMediaElementAudioSourceNode.mediaElement === undefined\n                ? this._mediaElement\n                : this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-element-audio-source-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n            super(context, false, nativeMediaStreamAudioDestinationNode, null);\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n        get stream() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-audio-destination-node-constructor.js.map","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-audio-source-node-constructor.js.map","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/media-stream-track-audio-source-node-constructor.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-audio-context-constructor.js.map","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n    return class MinimalBaseAudioContext extends eventTargetConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n            const sampleRate = _nativeContext.sampleRate;\n            Object.defineProperty(_nativeContext, 'sampleRate', {\n                get: () => sampleRate\n            });\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange =\n                nativeOnStateChange !== null && nativeOnStateChange === wrappedListener\n                    ? value\n                    : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-base-audio-context-constructor.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return (startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err;\n            }));\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/minimal-offline-audio-context-constructor.js.map","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set();\n        nativeAudioNode.connect = ((connect) => {\n            // tslint:disable-next-line:invalid-void\n            return (destination, output = 0, input = 0) => {\n                const wasDisconnected = connections.size === 0;\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    connect.call(nativeAudioNode, destination, output, input);\n                    insertElementInSet(connections, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n                    return destination;\n                }\n                connect.call(nativeAudioNode, destination, output);\n                insertElementInSet(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n                return;\n            };\n        })(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput, output, input) => {\n                const wasConnected = connections.size > 0;\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n                    connections.clear();\n                }\n                else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    disconnect.call(nativeAudioNode, destinationOrOutput);\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n                    }\n                    else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output);\n                    }\n                    for (const connection of connections) {\n                        if (connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                const isDisconnected = connections.size === 0;\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/monitor-connections.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-buffer-constructor.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-context-constructor.js.map","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Edge & Safari do not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            }\n            catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n        // Bug #83: Edge & Safari do not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            try {\n                nativeAudioDestinationNode.channelCount = value;\n            }\n            catch (err) {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                if (value > nativeAudioDestinationNode.maxChannelCount) {\n                    throw err;\n                }\n            }\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-destination-node.js.map","export const createNativeAudioNodeFactory = (getBackupNativeContext) => {\n    return (nativeContext, factoryFunction) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        if (backupNativeContext !== null) {\n            return factoryFunction(backupNativeContext);\n        }\n        return factoryFunction(nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-node-factory.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBiquadFilter());\n        assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n        assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n        return nativeBiquadFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-biquad-filter-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelMerger(options.numberOfInputs);\n        });\n        // Bug #15: Safari does not return the default properties.\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        if (nativeChannelMergerNode.channelCount !== 1 && nativeChannelMergerNode.channelCountMode !== 'explicit') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-channel-merger-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createConstantSource();\n        });\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-constant-source-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        try {\n            // Bug #166: Opera does not allow yet to set the channelCount to 1.\n            nativeConvolverNode.channelCount = 1;\n        }\n        catch (err) {\n            return createNativeConvolverNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Edge & Safari allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value > 2) {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        // Bug #114: Edge & Safari allow to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value === 'max') {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-convolver-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConvolverNodeFakerFactory = (createNativeAudioNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { buffer, channelCount, channelCountMode, channelInterpretation, disableNormalization }) => {\n        const convolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        assignNativeAudioNodeOptions(convolverNode, {\n            // Bug #166: Opera does not allow yet to set the channelCount to 1.\n            channelCount: Math.max(channelCount, 2),\n            // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n            channelCountMode: channelCountMode === 'max' ? channelCountMode : 'clamped-max',\n            channelInterpretation\n        });\n        const gainNode = createNativeGainNode(nativeContext, { channelCount, channelCountMode, channelInterpretation, gain: 1 });\n        const nativeConvolverNodeFaker = {\n            get buffer() {\n                return convolverNode.buffer;\n            },\n            set buffer(value) {\n                convolverNode.buffer = value;\n            },\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #166: Opera does not allow yet to set the channelCount to 1.\n                if (value > 2) {\n                    convolverNode.channelCount = value;\n                }\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n                if (value === 'max') {\n                    convolverNode.channelCountMode = value;\n                }\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return convolverNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                convolverNode.channelInterpretation = value;\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return convolverNode.context;\n            },\n            get inputs() {\n                return [convolverNode];\n            },\n            get numberOfInputs() {\n                return convolverNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return convolverNode.numberOfOutputs;\n            },\n            get normalize() {\n                return convolverNode.normalize;\n            },\n            set normalize(value) {\n                convolverNode.normalize = value;\n            },\n            addEventListener(...args) {\n                return convolverNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return convolverNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return convolverNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        // The normalize property needs to be set before setting the buffer.\n        if (disableNormalization === nativeConvolverNodeFaker.normalize) {\n            nativeConvolverNodeFaker.normalize = !disableNormalization;\n        }\n        if (buffer !== nativeConvolverNodeFaker.buffer) {\n            nativeConvolverNodeFaker.buffer = buffer;\n        }\n        const whenConnected = () => convolverNode.connect(gainNode);\n        const whenDisconnected = () => convolverNode.disconnect(gainNode);\n        return monitorConnections(interceptConnections(nativeConvolverNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-convolver-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeDelayNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDelay(options.maxDelayTime));\n        assignNativeAudioNodeOptions(nativeDelayNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n        return nativeDelayNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-delay-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDynamicsCompressor());\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-dynamics-compressor-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        assignNativeAudioNodeOptions(nativeGainNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n        return nativeGainNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-gain-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        const nativeIIRFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n        });\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-iir-filter-node-factory.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\nfunction multiply(a, b) {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const feedbackLength = feedback.length;\n        const feedforwardLength = feedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedback.length === 0 || feedback.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforward.length === 0 || feedforward.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                feedforward[i] /= feedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                feedback[i] /= feedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(feedforward, z);\n                    const denominator = evaluatePolynomial(feedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-iir-filter-node-faker-factory.js.map","export const createNativeMediaElementAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n        return ntvDCntxt.createMediaElementSource(options.mediaElement);\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-element-audio-source-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeAudioContext, options) => {\n        // Bug #64: Edge does not support MediaStreamAudioDestinationNodes.\n        if (nativeAudioContext.createMediaStreamDestination === undefined) {\n            throw createNotSupportedError();\n        }\n        const nativeMediaStreamAudioDestinationNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            return ntvDCntxt.createMediaStreamDestination();\n        });\n        assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n        // Bug #174: Safari does expose a wrong numberOfOutputs.\n        if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n            Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n        }\n        return nativeMediaStreamAudioDestinationNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-audio-destination-node-factory.js.map","export const createNativeMediaStreamAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStream }) => {\n        const audioStreamTracks = mediaStream.getAudioTracks();\n        const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            /*\n             * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n             * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n             */\n            const filteredAudioStreamTracks = audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0)).slice(0, 1);\n            return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n        });\n        // Bug #63: Edge does not expose the mediaStream yet.\n        Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-audio-source-node-factory.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n        }\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            const mediaStream = new MediaStream([mediaStreamTrack]);\n            const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream);\n            // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n            if (mediaStreamTrack.kind !== 'audio') {\n                throw createInvalidStateError();\n            }\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(ntvDCntxt)) {\n                throw new TypeError();\n            }\n            return nativeMediaStreamAudioSourceNode;\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=/build/es2019/factories/native-offline-audio-context-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-oscillator-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-panner-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n        let lastOrientation = [orientationX, orientationY, orientationZ];\n        let lastPosition = [positionX, positionY, positionZ];\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(3)[0],\n                inputBuffer.getChannelData(4)[0],\n                inputBuffer.getChannelData(5)[0]\n            ];\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n                // Bug #123: Edge does not support HRTF as panningModel.\n                if (pannerNode.panningModel !== value && value === 'HRTF') {\n                    throw createNotSupportedError();\n                }\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-panner-node-faker-factory.js.map","export const createNativePeriodicWaveFactory = (getBackupNativeContext) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n        const wrappedImag = new Float32Array(imag);\n        const wrappedReal = new Float32Array(real);\n        if (backupNativeContext !== null) {\n            return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n        }\n        return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-periodic-wave-factory.js.map","export const createNativeScriptProcessorNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n        return createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-script-processor-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => createNativeAudioNode(nativeContext, (ntvCntxt) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/native-stereo-panner-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve }));\n        return {\n            connectGraph() {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n        return {\n            connectGraph() {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs[0]);\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            connectGraph();\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n            isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch {\n            // Ignore errors.\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                    (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-wave-shaper-node-faker-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return (startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err;\n            }));\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/offline-audio-context-constructor.js.map","import { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class OscillatorNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = (isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n            if (value === 'custom') {\n                throw createInvalidStateError();\n            }\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/oscillator-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/oscillator-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class PannerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = (isOffline ? createPannerNodeRenderer() : null);\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let renderedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode(proxy);\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            }\n            else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all([\n                            proxy.orientationX,\n                            proxy.orientationY,\n                            proxy.orientationZ,\n                            proxy.positionX,\n                            proxy.positionY,\n                            proxy.positionZ\n                        ].map(async (audioParam, index) => {\n                            const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: index === 0 ? 1 : 0\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n                            return nativeConstantSourceNode;\n                        }));\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n                const channelDatas = [];\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n                inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n                    if (orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n                        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n                return nativeGainNode;\n            }\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/panner-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/periodic-wave-constructor.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-automation.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-inputs-of-audio-node.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-inputs-of-audio-param.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/render-native-offline-audio-context.js.map","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    const trace = [];\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, trace)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/start-rendering.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class StereoPannerNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = (isOffline ? createStereoPannerNodeRenderer() : null);\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n            // Bug #106: Edge does not export a maxValue and minValue property.\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/stereo-panner-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/stereo-panner-node-renderer-factory.js.map","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-constructor-support.js.map","/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n            return true;\n        }\n        const source = new Float32Array(2);\n        try {\n            nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js.map","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.start();\n        }\n        catch {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n        audioBuffer.getChannelData(0)[0] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.start(0, 0, 0);\n        audioBufferSourceNode.connect(offlineAudioContext.destination);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            offlineAudioContext.oncomplete = ({ renderedBuffer }) => {\n                // Bug #5: Safari does not support copyFromChannel().\n                resolve(renderedBuffer.getChannelData(0)[0] === 0);\n            };\n            offlineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js.map","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        try {\n            nativeAudioBufferSourceNode.start(0, 1);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.stop();\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const createTestAudioContextCloseMethodSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n            return true;\n        }\n        const audioContext = new nativeAudioContextConstructor();\n        const isAudioContextClosable = audioContext.close !== undefined;\n        try {\n            audioContext.close();\n        }\n        catch {\n            // Ignore errors.\n        }\n        return isAudioContextClosable;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-close-method-support.js.map","/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            let isPending = true;\n            const resolvePromise = (err) => {\n                if (isPending) {\n                    isPending = false;\n                    offlineAudioContext.startRendering();\n                    resolve(err instanceof TypeError);\n                }\n            };\n            let promise;\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                promise = offlineAudioContext\n                    // Bug #1: Safari requires a successCallback.\n                    .decodeAudioData(null, () => {\n                    // Ignore the success callback.\n                }, resolvePromise);\n            }\n            catch (err) {\n                resolvePromise(err);\n            }\n            // Bug #21: Safari does not support promises yet.\n            if (promise !== undefined) {\n                // Bug #6 Chrome does not call the errorCallback\n                promise.catch(resolvePromise);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js.map","export const createTestAudioContextOptionsSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        let audioContext;\n        try {\n            audioContext = new nativeAudioContextConstructor({ latencyHint: 'balanced' });\n        }\n        catch {\n            return false;\n        }\n        audioContext.close();\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-context-options-support.js.map","// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeGainNode = nativeOfflineAudioContext.createGain();\n        const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n        nativeGainNode.disconnect(nativeGainNode);\n        return isSupported;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-node-connect-method-support.js.map","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.start(-1);\n        }\n        catch (err) {\n            return err instanceof RangeError;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.start();\n        nativeAudioBufferSourceNode.stop();\n        try {\n            nativeAudioBufferSourceNode.stop();\n            return true;\n        }\n        catch {\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.stop(-1);\n        }\n        catch (err) {\n            return err instanceof RangeError;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const blob = new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor(\"a\",A)'], {\n            type: 'application/javascript; charset=utf-8'\n        });\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 3200);\n        const url = URL.createObjectURL(blob);\n        let isCallingProcess = false;\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n            const gainNode = offlineAudioContext.createGain();\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            audioWorkletNode.port.onmessage = () => (isCallingProcess = true);\n            gainNode.connect(audioWorkletNode);\n            await offlineAudioContext.startRendering();\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            URL.revokeObjectURL(url);\n        }\n        return isCallingProcess;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js.map","/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeChannelMergerNode = createNativeAudioNode(offlineAudioContext, (ntvCntxt) => ntvCntxt.createChannelMerger());\n        /**\n         * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support\n         * in other browsers.\n         */\n        if (nativeChannelMergerNode.channelCountMode === 'max') {\n            return true;\n        }\n        try {\n            nativeChannelMergerNode.channelCount = 2;\n        }\n        catch {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-channel-merger-node-channel-count-support.js.map","export const createTestConstantSourceNodeAccurateSchedulingSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return true;\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => ntvCntxt.createConstantSource());\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js.map","// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        try {\n            nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js.map","export const createTestIsSecureContextSupport = (window) => {\n    return () => window !== null && window.hasOwnProperty('isSecureContext');\n};\n//# sourceMappingURL=/build/es2019/factories/test-is-secure-context-support.js.map","// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n        const audioContext = new nativeAudioContextConstructor();\n        try {\n            audioContext.createMediaStreamSource(new MediaStream());\n            return false;\n        }\n        catch (err) {\n            return true;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-offline-audio-context-current-time-support.js.map","/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n            return Promise.resolve(true);\n        }\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return Promise.resolve(true);\n        }\n        const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n        stereoPanner.channelCount = 1;\n        constantSourceNode.start();\n        constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n        return nativeOfflineAudioContext.startRendering().then((buffer) => buffer.getChannelData(0)[0] !== 1);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/test-stereo-panner-node-default-value-support.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class WaveShaperNode extends audioNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = (isOffline ? createWaveShaperNodeRenderer() : null);\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wave-shaper-node-constructor.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wave-shaper-node-renderer-factory.js.map","export const createWindow = () => (typeof window === 'undefined' ? null : window);\n//# sourceMappingURL=/build/es2019/factories/window.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', (get) => () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n        }, (set) => (value) => {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode, monitorConnectionsFunction) => {\n    return (nativeContext, channelMergerNode) => {\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n        monitorConnectionsFunction(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/wrap-channel-merger-node.js.map","// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () => new Promise((resolve) => {\n    const arrayBuffer = new ArrayBuffer(0);\n    const { port1, port2 } = new MessageChannel();\n    port1.onmessage = ({ data }) => resolve(data !== null);\n    port2.postMessage(arrayBuffer, [arrayBuffer]);\n});\n//# sourceMappingURL=/build/es2019/helpers/test-transferables-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=/build/es2019/guards/audio-worklet-node.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/delete-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/is-passive-audio-node.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=/build/es2019/helpers/pick-element-from-set.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source.connect(analyzer).connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        // tslint:disable-next-line:deprecation\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=/build/es2019/helpers/visit-each-audio-node-once.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-node-disconnect-method.js.map","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n    return pickElementFromSet(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, input, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n    }\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);\n    }\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        const nativeSourceAudioNode = getNativeAudioNode(source);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isPassiveAudioNode(destination)) {\n                setInternalStateToActive(destination);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        const { activeInputs } = getAudioParamConnections(destination);\n        addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n        return true;\n    }\n    return false;\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => outputConnection[0] === destination &&\n        (output === undefined || outputConnection[1] === output) &&\n        (input === undefined || outputConnection[2] === input))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext);\n                    })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        // tslint:disable-next-line:invalid-void\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    if (isOffline || isPassiveAudioNode(this)) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    else if (isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                    // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n                    // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n                    if (isAudioWorkletNode(destination)) {\n                        const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeDestinationAudioNode);\n                        if (auxiliaryGainNodes === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodeStore.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n                        }\n                        else if (auxiliaryGainNodes.get(input) === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodes.set(input, nativeGainNode);\n                        }\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = isOffline\n                    ? addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input)\n                    : addConnectionToAudioNodeOfAudioContext(this, destination, output, input);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = isOffline\n                ? addConnectionToAudioParamOfOfflineAudioContext(this, destination, output)\n                : addConnectionToAudioParamOfAudioContext(this, destination, output);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-node-constructor.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/clone-audio-worklet-node-options.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=/build/es2019/helpers/create-audio-worklet-processor-promise.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => channelCount < 1)) {\n                throw createNotSupportedError();\n            }\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n            }\n        };\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode\n            .connect(nativeGainNode)\n            /*\n             * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n             * to make sure to connect the right destination.\n             */\n            .connect(nativeGainNode.context.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=/build/es2019/helpers/create-audio-worklet-processor.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2019/helpers/is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=/build/es2019/helpers/split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = new URL(moduleURL, window.location.href).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL).then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n                 * connected.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(\n                 *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *             outputs,\n                 *             parameters\n                 *         );\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = backupNativeContext !== null ? backupNativeContext : nativeContext;\n                return (nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    if (err.code === undefined || err.name === 'SyntaxError') {\n                        err.code = 12;\n                    }\n                    throw err;\n                }));\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.code === undefined || err.name === 'SyntaxError') {\n                err.code = 12;\n            }\n            throw err;\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/add-audio-worklet-module.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createAnalyser());\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-analyser-node-factory.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        // Bug #71: Edge does not allow to set the buffer to null.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #92: Chrome & Edge do not respect the duration parameter yet.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n            wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-buffer-source-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-renderer-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=/build/es2019/helpers/get-audio-worklet-processor.js.map","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)\n                ? new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate)\n                : nativeContext;\n            const promise = nativeContextOrBackupNativeContext.decodeAudioData(audioData).catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise.then((audioBuffer) => {\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch {\n                    // Ignore errors.\n                }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=/build/es2019/helpers/detach-array-buffer.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=/build/es2019/guards/delay-node.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/detect-cycles.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js.map","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class IIRFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null));\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/iir-filter-node-constructor.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map();\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = typeof value === 'function' ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = typeof args[1] === 'function'\n                                ? args[1]\n                                : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n                 * an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n                    nativeAudioWorkletNode\n                        .connect(nativeGainNode)\n                        /*\n                         * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                         * used here to make sure to connect the right destination.\n                         */\n                        .connect(nativeGainNode.context.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    /*\n                     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n                     * used here to make sure to connect the right destination.\n                     */\n                    const whenDisconnected = () => nativeGainNode.connect(nativeGainNode.context.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-audio-worklet-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n     * explicit.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n     * discrete.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=/build/es2019/helpers/wrap-channel-splitter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n        });\n        // Bug #96: Safari does not have the correct channelCount.\n        // Bug #29: Edge & Safari do not have the correct channelCountMode.\n        // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n        assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n        // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n        wrapChannelSplitterNode(nativeChannelSplitterNode);\n        return nativeChannelSplitterNode;\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/native-channel-splitter-node-factory.js.map","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement, error) {\n    if (!statement) {\n        throw new Error(error);\n    }\n}\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value, gte, lte = Infinity) {\n    if (!(gte <= value && value <= lte)) {\n        throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n    }\n}\n/**\n * Make sure that the given value is within the range\n */\nexport function assertContextRunning(context) {\n    // add a warning if the context is not started\n    if (!context.isOffline && context.state !== \"running\") {\n        warn(\"The AudioContext is \\\"suspended\\\". Invoke Tone.start() from a user action to start the audio.\");\n    }\n}\n/**\n * The default logger is the console\n */\nlet defaultLogger = console;\n/**\n * Set the logging interface\n */\nexport function setLogger(logger) {\n    defaultLogger = logger;\n}\n/**\n * Log anything\n */\nexport function log(...args) {\n    defaultLogger.log(...args);\n}\n/**\n * Warn anything\n */\nexport function warn(...args) {\n    defaultLogger.warn(...args);\n}\n//# sourceMappingURL=Debug.js.map","/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg) {\n    return typeof arg === \"undefined\";\n}\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined(arg) {\n    return !isUndef(arg);\n}\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg) {\n    return typeof arg === \"function\";\n}\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg) {\n    return (typeof arg === \"number\");\n}\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg) {\n    return (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg) {\n    return (typeof arg === \"boolean\");\n}\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg) {\n    return (Array.isArray(arg));\n}\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg) {\n    return (typeof arg === \"string\");\n}\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg) {\n    return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n//# sourceMappingURL=TypeCheck.js.map","import { AudioContext as stdAudioContext, AudioWorkletNode as stdAudioWorkletNode, OfflineAudioContext as stdOfflineAudioContext } from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(options) {\n    return new stdAudioContext(options);\n}\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels, length, sampleRate) {\n    return new stdOfflineAudioContext(channels, length, sampleRate);\n}\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow = typeof self === \"object\" ? self : null;\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n    (theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\nexport function createAudioWorkletNode(context, name, options) {\n    assert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\");\n    // @ts-ignore\n    return new stdAudioWorkletNode(context, name, options);\n}\n/**\n * This promise resolves to a boolean which indicates if the\n * functionality is supported within the currently used browse.\n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\nexport { isSupported as supported } from \"standardized-audio-context\";\n//# sourceMappingURL=AudioContext.js.map","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n    constructor(callback, type, updateInterval) {\n        this._callback = callback;\n        this._type = type;\n        this._updateInterval = updateInterval;\n        // create the clock source for the first time\n        this._createClock();\n    }\n    /**\n     * Generate a web worker\n     */\n    _createWorker() {\n        const blob = new Blob([\n            /* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n        ], { type: \"text/javascript\" });\n        const blobUrl = URL.createObjectURL(blob);\n        const worker = new Worker(blobUrl);\n        worker.onmessage = this._callback.bind(this);\n        this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n    _createTimeout() {\n        this._timeout = setTimeout(() => {\n            this._createTimeout();\n            this._callback();\n        }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n    _createClock() {\n        if (this._type === \"worker\") {\n            try {\n                this._createWorker();\n            }\n            catch (e) {\n                // workers not supported, fallback to timeout\n                this._type = \"timeout\";\n                this._createClock();\n            }\n        }\n        else if (this._type === \"timeout\") {\n            this._createTimeout();\n        }\n    }\n    /**\n     * Clean up the current clock source\n     */\n    _disposeClock() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = 0;\n        }\n        if (this._worker) {\n            this._worker.terminate();\n            this._worker.onmessage = null;\n        }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n    get updateInterval() {\n        return this._updateInterval;\n    }\n    set updateInterval(interval) {\n        this._updateInterval = Math.max(interval, 128 / 44100);\n        if (this._type === \"worker\") {\n            this._worker.postMessage(Math.max(interval * 1000, 1));\n        }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._disposeClock();\n        this._type = type;\n        this._createClock();\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this._disposeClock();\n    }\n}\n//# sourceMappingURL=Ticker.js.map","import { isAnyAudioContext, isAnyAudioNode, isAnyAudioParam, isAnyOfflineAudioContext, } from \"standardized-audio-context\";\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg) {\n    return isAnyAudioParam(arg);\n}\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg) {\n    return isAnyAudioNode(arg);\n}\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg) {\n    return isAnyOfflineAudioContext(arg);\n}\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg) {\n    return isAnyAudioContext(arg);\n}\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg) {\n    return arg instanceof AudioBuffer;\n}\n//# sourceMappingURL=AdvancedTypeCheck.js.map","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key, arg) {\n    return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\nexport function deepMerge(target, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (noCopy(key, source[key])) {\n                target[key] = source[key];\n            }\n            else if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                deepMerge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    // @ts-ignore\n    return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA, arrayB) {\n    return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n    const opts = {};\n    const args = Array.from(argsArray);\n    // if the first argument is an object and has an object key\n    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n        // if it's not part of the defaults\n        const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n        if (!partOfDefaults) {\n            // merge that key\n            deepMerge(opts, { [objKey]: args[0] });\n            // remove the obj key from the keys\n            keys.splice(keys.indexOf(objKey), 1);\n            // shift the first argument off\n            args.shift();\n        }\n    }\n    if (args.length === 1 && isObject(args[0])) {\n        deepMerge(opts, args[0]);\n    }\n    else {\n        for (let i = 0; i < keys.length; i++) {\n            if (isDefined(args[i])) {\n                opts[keys[i]] = args[i];\n            }\n        }\n    }\n    return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance(instance) {\n    return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg(given, fallback) {\n    if (isUndef(given)) {\n        return fallback;\n    }\n    else {\n        return given;\n    }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject(obj, omit) {\n    omit.forEach(prop => {\n        if (Reflect.has(obj, prop)) {\n            delete obj[prop];\n        }\n    });\n    return obj;\n}\n//# sourceMappingURL=Defaults.js.map","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { log } from \"./util/Debug\";\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\nexport class Tone {\n    constructor() {\n        //-------------------------------------\n        // \tDEBUGGING\n        //-------------------------------------\n        /**\n         * Set this debug flag to log all events that happen in this class.\n         */\n        this.debug = false;\n        //-------------------------------------\n        // \tDISPOSING\n        //-------------------------------------\n        /**\n         * Indicates if the instance was disposed\n         */\n        this._wasDisposed = false;\n    }\n    /**\n     * Returns all of the default options belonging to the class.\n     */\n    static getDefaults() {\n        return {};\n    }\n    /**\n     * Prints the outputs to the console log for debugging purposes.\n     * Prints the contents only if either the object has a property\n     * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n     * is set to the name of the class.\n     * @example\n     * const osc = new Tone.Oscillator();\n     * // prints all logs originating from this oscillator\n     * osc.debug = true;\n     * // calls to start/stop will print in the console\n     * osc.start();\n     */\n    log(...args) {\n        // if the object is either set to debug = true\n        // or if there is a string on the Tone.global.with the class name\n        if (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n            log(this, ...args);\n        }\n    }\n    /**\n     * disconnect and dispose.\n     */\n    dispose() {\n        this._wasDisposed = true;\n        return this;\n    }\n    /**\n     * Indicates if the instance was disposed. 'Disposing' an\n     * instance means that all of the Web Audio nodes that were\n     * created for the instance are disconnected and freed for garbage collection.\n     */\n    get disposed() {\n        return this._wasDisposed;\n    }\n    /**\n     * Convert the class to a string\n     * @example\n     * const osc = new Tone.Oscillator();\n     * console.log(osc.toString());\n     */\n    toString() {\n        return this.name;\n    }\n}\n/**\n * The version number semver\n */\nTone.version = version;\n//# sourceMappingURL=Tone.js.map","export const version = \"14.7.30\";\n//# sourceMappingURL=version.js.map","/**\n * The threshold for correctness for operators. Less than one sample even\n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n/**\n * Test if A is greater than B\n */\nexport function GT(a, b) {\n    return a > b + EPSILON;\n}\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a, b) {\n    return GT(a, b) || EQ(a, b);\n}\n/**\n * Test if A is less than B\n */\nexport function LT(a, b) {\n    return a + EPSILON < b;\n}\n/**\n * Test if A is less than B\n */\nexport function EQ(a, b) {\n    return Math.abs(a - b) < EPSILON;\n}\n/**\n * Clamp the value within the given range\n */\nexport function clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n//# sourceMappingURL=Math.js.map","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline extends Tone {\n    constructor() {\n        super();\n        this.name = \"Timeline\";\n        /**\n         * The array of scheduled timeline events\n         */\n        this._timeline = [];\n        const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n        this.memory = options.memory;\n        this.increasing = options.increasing;\n    }\n    static getDefaults() {\n        return {\n            memory: Infinity,\n            increasing: false,\n        };\n    }\n    /**\n     * The number of items in the timeline.\n     */\n    get length() {\n        return this._timeline.length;\n    }\n    /**\n     * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n     * @param event  The event object to insert into the timeline.\n     */\n    add(event) {\n        // the event needs to have a time attribute\n        assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n        event.time = event.time.valueOf();\n        if (this.increasing && this.length) {\n            const lastValue = this._timeline[this.length - 1];\n            assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n            this._timeline.push(event);\n        }\n        else {\n            const index = this._search(event.time);\n            this._timeline.splice(index + 1, 0, event);\n        }\n        // if the length is more than the memory, remove the previous ones\n        if (this.length > this.memory) {\n            const diff = this.length - this.memory;\n            this._timeline.splice(0, diff);\n        }\n        return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  {Object}  event  The event object to remove from the list.\n     * @returns {Timeline} this\n     */\n    remove(event) {\n        const index = this._timeline.indexOf(event);\n        if (index !== -1) {\n            this._timeline.splice(index, 1);\n        }\n        return this;\n    }\n    /**\n     * Get the nearest event whose time is less than or equal to the given time.\n     * @param  time  The time to query.\n     */\n    get(time, param = \"time\") {\n        const index = this._search(time, param);\n        if (index !== -1) {\n            return this._timeline[index];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Return the first event in the timeline without removing it\n     * @returns {Object} The first event object\n     */\n    peek() {\n        return this._timeline[0];\n    }\n    /**\n     * Return the first event in the timeline and remove it\n     */\n    shift() {\n        return this._timeline.shift();\n    }\n    /**\n     * Get the event which is scheduled after the given time.\n     * @param  time  The time to query.\n     */\n    getAfter(time, param = \"time\") {\n        const index = this._search(time, param);\n        if (index + 1 < this._timeline.length) {\n            return this._timeline[index + 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Get the event before the event at the given time.\n     * @param  time  The time to query.\n     */\n    getBefore(time) {\n        const len = this._timeline.length;\n        // if it's after the last item, return the last item\n        if (len > 0 && this._timeline[len - 1].time < time) {\n            return this._timeline[len - 1];\n        }\n        const index = this._search(time);\n        if (index - 1 >= 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Cancel events at and after the given time\n     * @param  after  The time to query.\n     */\n    cancel(after) {\n        if (this._timeline.length > 1) {\n            let index = this._search(after);\n            if (index >= 0) {\n                if (EQ(this._timeline[index].time, after)) {\n                    // get the first item with that time\n                    for (let i = index; i >= 0; i--) {\n                        if (EQ(this._timeline[i].time, after)) {\n                            index = i;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    this._timeline = this._timeline.slice(0, index);\n                }\n                else {\n                    this._timeline = this._timeline.slice(0, index + 1);\n                }\n            }\n            else {\n                this._timeline = [];\n            }\n        }\n        else if (this._timeline.length === 1) {\n            // the first item's time\n            if (GTE(this._timeline[0].time, after)) {\n                this._timeline = [];\n            }\n        }\n        return this;\n    }\n    /**\n     * Cancel events before or equal to the given time.\n     * @param  time  The time to cancel before.\n     */\n    cancelBefore(time) {\n        const index = this._search(time);\n        if (index >= 0) {\n            this._timeline = this._timeline.slice(index + 1);\n        }\n        return this;\n    }\n    /**\n     * Returns the previous event if there is one. null otherwise\n     * @param  event The event to find the previous one of\n     * @return The event right before the given event\n     */\n    previousEvent(event) {\n        const index = this._timeline.indexOf(event);\n        if (index > 0) {\n            return this._timeline[index - 1];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Does a binary search on the timeline array and returns the\n     * nearest event index whose time is after or equal to the given time.\n     * If a time is searched before the first index in the timeline, -1 is returned.\n     * If the time is after the end, the index of the last item is returned.\n     */\n    _search(time, param = \"time\") {\n        if (this._timeline.length === 0) {\n            return -1;\n        }\n        let beginning = 0;\n        const len = this._timeline.length;\n        let end = len;\n        if (len > 0 && this._timeline[len - 1][param] <= time) {\n            return len - 1;\n        }\n        while (beginning < end) {\n            // calculate the midpoint for roughly equal partition\n            let midPoint = Math.floor(beginning + (end - beginning) / 2);\n            const event = this._timeline[midPoint];\n            const nextEvent = this._timeline[midPoint + 1];\n            if (EQ(event[param], time)) {\n                // choose the last one that has the same time\n                for (let i = midPoint; i < this._timeline.length; i++) {\n                    const testEvent = this._timeline[i];\n                    if (EQ(testEvent[param], time)) {\n                        midPoint = i;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                return midPoint;\n            }\n            else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n                return midPoint;\n            }\n            else if (GT(event[param], time)) {\n                // search lower\n                end = midPoint;\n            }\n            else {\n                // search upper\n                beginning = midPoint + 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Internal iterator. Applies extra safety checks for\n     * removing items from the array.\n     */\n    _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {\n        this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n    }\n    /**\n     * Iterate over everything in the array\n     * @param  callback The callback to invoke with every item\n     */\n    forEach(callback) {\n        this._iterate(callback);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at or before the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachBefore(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const upperBound = this._search(time);\n        if (upperBound !== -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array after the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAfter(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const lowerBound = this._search(time);\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array between the startTime and endTime.\n     * The timerange is inclusive of the startTime, but exclusive of the endTime.\n     * range = [startTime, endTime).\n     * @param  startTime The time to check if items are before\n     * @param  endTime The end of the test interval.\n     * @param  callback The callback to invoke with every item\n     */\n    forEachBetween(startTime, endTime, callback) {\n        let lowerBound = this._search(startTime);\n        let upperBound = this._search(endTime);\n        if (lowerBound !== -1 && upperBound !== -1) {\n            if (this._timeline[lowerBound].time !== startTime) {\n                lowerBound += 1;\n            }\n            // exclusive of the end time\n            if (this._timeline[upperBound].time === endTime) {\n                upperBound -= 1;\n            }\n            this._iterate(callback, lowerBound, upperBound);\n        }\n        else if (lowerBound === -1) {\n            this._iterate(callback, 0, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at or after the given time. Similar to\n     * forEachAfter, but includes the item(s) at the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachFrom(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        let lowerBound = this._search(time);\n        // work backwards until the event time is less than time\n        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n            lowerBound--;\n        }\n        this._iterate(callback, lowerBound + 1);\n        return this;\n    }\n    /**\n     * Iterate over everything in the array at the given time\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAtTime(time, callback) {\n        // iterate over the items in reverse so that removing an item doesn't break things\n        const upperBound = this._search(time);\n        if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n            let lowerBound = upperBound;\n            for (let i = upperBound; i >= 0; i--) {\n                if (EQ(this._timeline[i].time, time)) {\n                    lowerBound = i;\n                }\n                else {\n                    break;\n                }\n            }\n            this._iterate(event => {\n                callback(event);\n            }, lowerBound, upperBound);\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._timeline = [];\n        return this;\n    }\n}\n//# sourceMappingURL=Timeline.js.map","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext = [];\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb) {\n    notifyNewContext.push(cb);\n}\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx) {\n    // add any additional modules\n    notifyNewContext.forEach(cb => cb(ctx));\n}\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext = [];\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb) {\n    notifyCloseContext.push(cb);\n}\nexport function closeContext(ctx) {\n    // add any additional modules\n    notifyCloseContext.forEach(cb => cb(ctx));\n}\n//# sourceMappingURL=ContextInitialization.js.map","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"Emitter\";\n    }\n    /**\n     * Bind a callback to a specific event.\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    on(event, callback) {\n        // split the event\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (!this._events.hasOwnProperty(eventName)) {\n                this._events[eventName] = [];\n            }\n            this._events[eventName].push(callback);\n        });\n        return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    once(event, callback) {\n        const boundCallback = (...args) => {\n            // invoke the callback\n            callback(...args);\n            // remove the event\n            this.off(event, boundCallback);\n        };\n        this.on(event, boundCallback);\n        return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n    off(event, callback) {\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (this._events.hasOwnProperty(event)) {\n                if (isUndef(callback)) {\n                    this._events[event] = [];\n                }\n                else {\n                    const eventList = this._events[event];\n                    for (let i = 0; i < eventList.length; i++) {\n                        if (eventList[i] === callback) {\n                            eventList.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        });\n        return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n    emit(event, ...args) {\n        if (this._events) {\n            if (this._events.hasOwnProperty(event)) {\n                const eventList = this._events[event].slice(0);\n                for (let i = 0, len = eventList.length; i < len; i++) {\n                    eventList[i].apply(this, args);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n    static mixin(constr) {\n        // instance._events = {};\n        [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n            const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n            Object.defineProperty(constr.prototype, name, property);\n        });\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._events = undefined;\n        return this;\n    }\n}\n//# sourceMappingURL=Emitter.js.map","import { Emitter } from \"../util/Emitter\";\nexport class BaseContext extends Emitter {\n    constructor() {\n        super(...arguments);\n        this.isOffline = false;\n    }\n}\n//# sourceMappingURL=BaseContext.js.map","import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n    constructor() {\n        super();\n        this.name = \"Context\";\n        /**\n         * An object containing all of the constants AudioBufferSourceNodes\n         */\n        this._constants = new Map();\n        /**\n         * All of the setTimeout events.\n         */\n        this._timeouts = new Timeline();\n        /**\n         * The timeout id counter\n         */\n        this._timeoutIds = 0;\n        /**\n         * Private indicator if the context has been initialized\n         */\n        this._initialized = false;\n        /**\n         * Indicates if the context is an OfflineAudioContext or an AudioContext\n         */\n        this.isOffline = false;\n        //--------------------------------------------\n        // AUDIO WORKLET\n        //--------------------------------------------\n        /**\n         * Maps a module name to promise of the addModule method\n         */\n        this._workletModules = new Map();\n        const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n        if (options.context) {\n            this._context = options.context;\n        }\n        else {\n            this._context = createAudioContext({\n                latencyHint: options.latencyHint,\n            });\n        }\n        this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n        this.on(\"tick\", this._timeoutLoop.bind(this));\n        // fwd events from the context\n        this._context.onstatechange = () => {\n            this.emit(\"statechange\", this.state);\n        };\n        this._setLatencyHint(options.latencyHint);\n        this.lookAhead = options.lookAhead;\n    }\n    static getDefaults() {\n        return {\n            clockSource: \"worker\",\n            latencyHint: \"interactive\",\n            lookAhead: 0.1,\n            updateInterval: 0.05,\n        };\n    }\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    initialize() {\n        if (!this._initialized) {\n            // add any additional modules\n            initializeContext(this);\n            this._initialized = true;\n        }\n        return this;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return this._context.createAnalyser();\n    }\n    createOscillator() {\n        return this._context.createOscillator();\n    }\n    createBufferSource() {\n        return this._context.createBufferSource();\n    }\n    createBiquadFilter() {\n        return this._context.createBiquadFilter();\n    }\n    createBuffer(numberOfChannels, length, sampleRate) {\n        return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n    createChannelMerger(numberOfInputs) {\n        return this._context.createChannelMerger(numberOfInputs);\n    }\n    createChannelSplitter(numberOfOutputs) {\n        return this._context.createChannelSplitter(numberOfOutputs);\n    }\n    createConstantSource() {\n        return this._context.createConstantSource();\n    }\n    createConvolver() {\n        return this._context.createConvolver();\n    }\n    createDelay(maxDelayTime) {\n        return this._context.createDelay(maxDelayTime);\n    }\n    createDynamicsCompressor() {\n        return this._context.createDynamicsCompressor();\n    }\n    createGain() {\n        return this._context.createGain();\n    }\n    createIIRFilter(feedForward, feedback) {\n        // @ts-ignore\n        return this._context.createIIRFilter(feedForward, feedback);\n    }\n    createPanner() {\n        return this._context.createPanner();\n    }\n    createPeriodicWave(real, imag, constraints) {\n        return this._context.createPeriodicWave(real, imag, constraints);\n    }\n    createStereoPanner() {\n        return this._context.createStereoPanner();\n    }\n    createWaveShaper() {\n        return this._context.createWaveShaper();\n    }\n    createMediaStreamSource(stream) {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamSource(stream);\n    }\n    createMediaStreamDestination() {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamDestination();\n    }\n    decodeAudioData(audioData) {\n        return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get currentTime() {\n        return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get state() {\n        return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get sampleRate() {\n        return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n    get listener() {\n        this.initialize();\n        return this._listener;\n    }\n    set listener(l) {\n        assert(!this._initialized, \"The listener cannot be set after initialization.\");\n        this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n    get transport() {\n        this.initialize();\n        return this._transport;\n    }\n    set transport(t) {\n        assert(!this._initialized, \"The transport cannot be set after initialization.\");\n        this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n    get draw() {\n        this.initialize();\n        return this._draw;\n    }\n    set draw(d) {\n        assert(!this._initialized, \"Draw cannot be set after initialization.\");\n        this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n    get destination() {\n        this.initialize();\n        return this._destination;\n    }\n    set destination(d) {\n        assert(!this._initialized, \"The destination cannot be set after initialization.\");\n        this._destination = d;\n    }\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n    createAudioWorkletNode(name, options) {\n        return createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n    addAudioWorkletModule(url, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n            if (!this._workletModules.has(name)) {\n                this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n            }\n            yield this._workletModules.get(name);\n        });\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n    workletsAreReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = [];\n            this._workletModules.forEach(promise => promises.push(promise));\n            yield Promise.all(promises);\n        });\n    }\n    //---------------------------\n    // TICKER\n    //---------------------------\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n    get updateInterval() {\n        return this._ticker.updateInterval;\n    }\n    set updateInterval(interval) {\n        this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n    get clockSource() {\n        return this._ticker.type;\n    }\n    set clockSource(type) {\n        this._ticker.type = type;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     */\n    get latencyHint() {\n        return this._latencyHint;\n    }\n    /**\n     * Update the lookAhead and updateInterval based on the latencyHint\n     */\n    _setLatencyHint(hint) {\n        let lookAheadValue = 0;\n        this._latencyHint = hint;\n        if (isString(hint)) {\n            switch (hint) {\n                case \"interactive\":\n                    lookAheadValue = 0.1;\n                    break;\n                case \"playback\":\n                    lookAheadValue = 0.5;\n                    break;\n                case \"balanced\":\n                    lookAheadValue = 0.25;\n                    break;\n            }\n        }\n        this.lookAhead = lookAheadValue;\n        this.updateInterval = lookAheadValue / 2;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n    get rawContext() {\n        return this._context;\n    }\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n    now() {\n        return this._context.currentTime + this.lookAhead;\n    }\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n    immediate() {\n        return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext. See [[Tone.start]]\n     */\n    resume() {\n        if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n            return this._context.resume();\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (isAudioContext(this._context)) {\n                yield this._context.close();\n            }\n            if (this._initialized) {\n                closeContext(this);\n            }\n        });\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n    getConstant(val) {\n        if (this._constants.has(val)) {\n            return this._constants.get(val);\n        }\n        else {\n            const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n            const arr = buffer.getChannelData(0);\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = val;\n            }\n            const constant = this._context.createBufferSource();\n            constant.channelCount = 1;\n            constant.channelCountMode = \"explicit\";\n            constant.buffer = buffer;\n            constant.loop = true;\n            constant.start(0);\n            this._constants.set(val, constant);\n            return constant;\n        }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n    dispose() {\n        super.dispose();\n        this._ticker.dispose();\n        this._timeouts.dispose();\n        Object.keys(this._constants).map(val => this._constants[val].disconnect());\n        return this;\n    }\n    //---------------------------\n    // TIMEOUTS\n    //---------------------------\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n    _timeoutLoop() {\n        const now = this.now();\n        let firstEvent = this._timeouts.peek();\n        while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n            // invoke the callback\n            firstEvent.callback();\n            // shift the first event off\n            this._timeouts.shift();\n            // get the next one\n            firstEvent = this._timeouts.peek();\n        }\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n    setTimeout(fn, timeout) {\n        this._timeoutIds++;\n        const now = this.now();\n        this._timeouts.add({\n            callback: fn,\n            id: this._timeoutIds,\n            time: now + timeout,\n        });\n        return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n    clearTimeout(id) {\n        this._timeouts.forEach(event => {\n            if (event.id === id) {\n                this._timeouts.remove(event);\n            }\n        });\n        return this;\n    }\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n    clearInterval(id) {\n        return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n    setInterval(fn, interval) {\n        const id = ++this._timeoutIds;\n        const intervalFn = () => {\n            const now = this.now();\n            this._timeouts.add({\n                callback: () => {\n                    // invoke the callback\n                    fn();\n                    // invoke the event to repeat it\n                    intervalFn();\n                },\n                id,\n                time: now + interval,\n            });\n        };\n        // kick it off\n        intervalFn();\n        return id;\n    }\n}\n//# sourceMappingURL=Context.js.map","import { isArray } from \"./TypeCheck\";\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target, property) {\n    if (isArray(property)) {\n        property.forEach(str => readOnly(target, str));\n    }\n    else {\n        Object.defineProperty(target, property, {\n            enumerable: true,\n            writable: false,\n        });\n    }\n}\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target, property) {\n    if (isArray(property)) {\n        property.forEach(str => writable(target, str));\n    }\n    else {\n        Object.defineProperty(target, property, {\n            writable: true,\n        });\n    }\n}\nexport const noOp = () => {\n    // no operation here!\n};\n//# sourceMappingURL=Interface.js.map","import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n    constructor() {\n        super();\n        this.name = \"ToneAudioBuffer\";\n        /**\n         * Callback when the buffer is loaded.\n         */\n        this.onload = noOp;\n        const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n        this.reverse = options.reverse;\n        this.onload = options.onload;\n        if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n            this.set(options.url);\n        }\n        else if (isString(options.url)) {\n            // initiate the download\n            this.load(options.url).catch(options.onerror);\n        }\n    }\n    static getDefaults() {\n        return {\n            onerror: noOp,\n            onload: noOp,\n            reverse: false,\n        };\n    }\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    get sampleRate() {\n        if (this._buffer) {\n            return this._buffer.sampleRate;\n        }\n        else {\n            return getContext().sampleRate;\n        }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n    set(buffer) {\n        if (buffer instanceof ToneAudioBuffer) {\n            // if it's loaded, set it\n            if (buffer.loaded) {\n                this._buffer = buffer.get();\n            }\n            else {\n                // otherwise when it's loaded, invoke it's callback\n                buffer.onload = () => {\n                    this.set(buffer);\n                    this.onload(this);\n                };\n            }\n        }\n        else {\n            this._buffer = buffer;\n        }\n        // reverse it initially\n        if (this._reversed) {\n            this._reverse();\n        }\n        return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n    get() {\n        return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n                this.set(audioBuffer);\n                // invoke the onload method\n                this.onload(this);\n            });\n            ToneAudioBuffer.downloads.push(doneLoading);\n            try {\n                yield doneLoading;\n            }\n            finally {\n                // remove the downloaded file\n                const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n            }\n            return this;\n        });\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffer = undefined;\n        return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n    fromArray(array) {\n        const isMultidimensional = isArray(array) && array[0].length > 0;\n        const channels = isMultidimensional ? array.length : 1;\n        const len = isMultidimensional ? array[0].length : array.length;\n        const context = getContext();\n        const buffer = context.createBuffer(channels, len, context.sampleRate);\n        const multiChannelArray = !isMultidimensional && channels === 1 ?\n            [array] : array;\n        for (let c = 0; c < channels; c++) {\n            buffer.copyToChannel(multiChannelArray[c], c);\n        }\n        this._buffer = buffer;\n        return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n    toMono(chanNum) {\n        if (isNumber(chanNum)) {\n            this.fromArray(this.toArray(chanNum));\n        }\n        else {\n            let outputArray = new Float32Array(this.length);\n            const numChannels = this.numberOfChannels;\n            for (let channel = 0; channel < numChannels; channel++) {\n                const channelArray = this.toArray(channel);\n                for (let i = 0; i < channelArray.length; i++) {\n                    outputArray[i] += channelArray[i];\n                }\n            }\n            // divide by the number of channels\n            outputArray = outputArray.map(sample => sample / numChannels);\n            this.fromArray(outputArray);\n        }\n        return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n    toArray(channel) {\n        if (isNumber(channel)) {\n            return this.getChannelData(channel);\n        }\n        else if (this.numberOfChannels === 1) {\n            return this.toArray(0);\n        }\n        else {\n            const ret = [];\n            for (let c = 0; c < this.numberOfChannels; c++) {\n                ret[c] = this.getChannelData(c);\n            }\n            return ret;\n        }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n    getChannelData(channel) {\n        if (this._buffer) {\n            return this._buffer.getChannelData(channel);\n        }\n        else {\n            return new Float32Array(0);\n        }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n    slice(start, end = this.duration) {\n        const startSamples = Math.floor(start * this.sampleRate);\n        const endSamples = Math.floor(end * this.sampleRate);\n        assert(startSamples < endSamples, \"The start time must be less than the end time\");\n        const length = endSamples - startSamples;\n        const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n        for (let channel = 0; channel < this.numberOfChannels; channel++) {\n            retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n        }\n        return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n    _reverse() {\n        if (this.loaded) {\n            for (let i = 0; i < this.numberOfChannels; i++) {\n                this.getChannelData(i).reverse();\n            }\n        }\n        return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n    get loaded() {\n        return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n    get duration() {\n        if (this._buffer) {\n            return this._buffer.duration;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n    get length() {\n        if (this._buffer) {\n            return this._buffer.length;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n    get numberOfChannels() {\n        if (this._buffer) {\n            return this._buffer.numberOfChannels;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Reverse the buffer.\n     */\n    get reverse() {\n        return this._reversed;\n    }\n    set reverse(rev) {\n        if (this._reversed !== rev) {\n            this._reversed = rev;\n            this._reverse();\n        }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n    static fromArray(array) {\n        return (new ToneAudioBuffer()).fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n    static fromUrl(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buffer = new ToneAudioBuffer();\n            return yield buffer.load(url);\n        });\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n    static load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // test if the url contains multiple extensions\n            const matches = url.match(/\\[(.+\\|?)+\\]$/);\n            if (matches) {\n                const extensions = matches[1].split(\"|\");\n                let extension = extensions[0];\n                for (const ext of extensions) {\n                    if (ToneAudioBuffer.supportsType(ext)) {\n                        extension = ext;\n                        break;\n                    }\n                }\n                url = url.replace(matches[0], extension);\n            }\n            // make sure there is a slash between the baseUrl and the url\n            const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n            const response = yield fetch(baseUrl + url);\n            if (!response.ok) {\n                throw new Error(`could not load url: ${url}`);\n            }\n            const arrayBuffer = yield response.arrayBuffer();\n            const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n            return audioBuffer;\n        });\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n    static supportsType(url) {\n        const extensions = url.split(\".\");\n        const extension = extensions[extensions.length - 1];\n        const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n        return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n    static loaded() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // this makes sure that the function is always async\n            yield Promise.resolve();\n            while (ToneAudioBuffer.downloads.length) {\n                yield ToneAudioBuffer.downloads[0];\n            }\n        });\n    }\n}\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];\n//# sourceMappingURL=ToneAudioBuffer.js.map","import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n    constructor() {\n        super({\n            clockSource: \"offline\",\n            context: isOfflineAudioContext(arguments[0]) ?\n                arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n            lookAhead: 0,\n            updateInterval: isOfflineAudioContext(arguments[0]) ?\n                128 / arguments[0].sampleRate : 128 / arguments[2],\n        });\n        this.name = \"OfflineContext\";\n        /**\n         * An artificial clock source\n         */\n        this._currentTime = 0;\n        this.isOffline = true;\n        this._duration = isOfflineAudioContext(arguments[0]) ?\n            arguments[0].length / arguments[0].sampleRate : arguments[1];\n    }\n    /**\n     * Override the now method to point to the internal clock time\n     */\n    now() {\n        return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n    get currentTime() {\n        return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    _renderClock(asynchronous) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let index = 0;\n            while (this._duration - this._currentTime >= 0) {\n                // invoke all the callbacks on that time\n                this.emit(\"tick\");\n                // increment the clock in block-sized chunks\n                this._currentTime += 128 / this.sampleRate;\n                // yield once a second of audio\n                index++;\n                const yieldEvery = Math.floor(this.sampleRate / 128);\n                if (asynchronous && index % yieldEvery === 0) {\n                    yield new Promise(done => setTimeout(done, 1));\n                }\n            }\n        });\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n    render(asynchronous = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.workletsAreReady();\n            yield this._renderClock(asynchronous);\n            const buffer = yield this._context.startRendering();\n            return new ToneAudioBuffer(buffer);\n        });\n    }\n    /**\n     * Close the context\n     */\n    close() {\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=OfflineContext.js.map","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext = dummyContext;\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\nexport function getContext() {\n    if (globalContext === dummyContext && hasAudioContext) {\n        setContext(new Context());\n    }\n    return globalContext;\n}\n/**\n * Set the default audio context\n * @category Core\n */\nexport function setContext(context) {\n    if (isAudioContext(context)) {\n        globalContext = new Context(context);\n    }\n    else if (isOfflineAudioContext(context)) {\n        globalContext = new OfflineContext(context);\n    }\n    else {\n        globalContext = context;\n    }\n}\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start() {\n    return globalContext.resume();\n}\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n    let prefix = \"v\";\n    if (version === \"dev\") {\n        prefix = \"\";\n    }\n    const printString = ` * Tone.js ${prefix}${version} * `;\n    // eslint-disable-next-line no-console\n    console.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n//# sourceMappingURL=Global.js.map","import { __awaiter } from \"tslib\";\nimport { BaseContext } from \"./BaseContext\";\nexport class DummyContext extends BaseContext {\n    constructor() {\n        super(...arguments);\n        this.lookAhead = 0;\n        this.latencyHint = 0;\n        this.isOffline = false;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return {};\n    }\n    createOscillator() {\n        return {};\n    }\n    createBufferSource() {\n        return {};\n    }\n    createBiquadFilter() {\n        return {};\n    }\n    createBuffer(_numberOfChannels, _length, _sampleRate) {\n        return {};\n    }\n    createChannelMerger(_numberOfInputs) {\n        return {};\n    }\n    createChannelSplitter(_numberOfOutputs) {\n        return {};\n    }\n    createConstantSource() {\n        return {};\n    }\n    createConvolver() {\n        return {};\n    }\n    createDelay(_maxDelayTime) {\n        return {};\n    }\n    createDynamicsCompressor() {\n        return {};\n    }\n    createGain() {\n        return {};\n    }\n    createIIRFilter(_feedForward, _feedback) {\n        return {};\n    }\n    createPanner() {\n        return {};\n    }\n    createPeriodicWave(_real, _imag, _constraints) {\n        return {};\n    }\n    createStereoPanner() {\n        return {};\n    }\n    createWaveShaper() {\n        return {};\n    }\n    createMediaStreamSource(_stream) {\n        return {};\n    }\n    createMediaStreamDestination() {\n        return {};\n    }\n    decodeAudioData(_audioData) {\n        return Promise.resolve({});\n    }\n    //---------------------------\n    // TONE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAudioWorkletNode(_name, _options) {\n        return {};\n    }\n    get rawContext() {\n        return {};\n    }\n    addAudioWorkletModule(_url, _name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve();\n        });\n    }\n    resume() {\n        return Promise.resolve();\n    }\n    setTimeout(_fn, _timeout) {\n        return 0;\n    }\n    clearTimeout(_id) {\n        return this;\n    }\n    setInterval(_fn, _interval) {\n        return 0;\n    }\n    clearInterval(_id) {\n        return this;\n    }\n    getConstant(_val) {\n        return {};\n    }\n    get currentTime() {\n        return 0;\n    }\n    get state() {\n        return {};\n    }\n    get sampleRate() {\n        return 0;\n    }\n    get listener() {\n        return {};\n    }\n    get transport() {\n        return {};\n    }\n    get draw() {\n        return {};\n    }\n    set draw(_d) { }\n    get destination() {\n        return {};\n    }\n    set destination(_d) { }\n    now() {\n        return 0;\n    }\n    immediate() {\n        return 0;\n    }\n}\n//# sourceMappingURL=DummyContext.js.map","/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent) {\n    const piFactor = 0.5 * Math.PI;\n    return Math.sin(percent * piFactor);\n}\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db) {\n    return Math.pow(10, db / 20);\n}\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain) {\n    return 20 * (Math.log(gain) / Math.LN10);\n}\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval) {\n    return Math.pow(2, (interval / 12));\n}\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4 = 440;\nexport function getA4() {\n    return A4;\n}\nexport function setA4(freq) {\n    A4 = freq;\n}\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\nexport function ftom(frequency) {\n    return Math.round(ftomf(frequency));\n}\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency) {\n    return 69 + 12 * Math.log2(frequency / A4);\n}\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\nexport function mtof(midi) {\n    return A4 * Math.pow(2, (midi - 69) / 12);\n}\n//# sourceMappingURL=Conversions.js.map","import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport class TimeBaseClass extends Tone {\n    /**\n     * @param context The context associated with the time value. Used to compute\n     * Transport and context-relative timing.\n     * @param  value  The time value as a number, string or object\n     * @param  units  Unit values\n     */\n    constructor(context, value, units) {\n        super();\n        /**\n         * The default units\n         */\n        this.defaultUnits = \"s\";\n        this._val = value;\n        this._units = units;\n        this.context = context;\n        this._expressions = this._getExpressions();\n    }\n    /**\n     * All of the time encoding expressions\n     */\n    _getExpressions() {\n        return {\n            hz: {\n                method: (value) => {\n                    return this._frequencyToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n            },\n            i: {\n                method: (value) => {\n                    return this._ticksToUnits(parseInt(value, 10));\n                },\n                regexp: /^(\\d+)i$/i,\n            },\n            m: {\n                method: (value) => {\n                    return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n                },\n                regexp: /^(\\d+)m$/i,\n            },\n            n: {\n                method: (value, dot) => {\n                    const numericValue = parseInt(value, 10);\n                    const scalar = dot === \".\" ? 1.5 : 1;\n                    if (numericValue === 1) {\n                        return this._beatsToUnits(this._getTimeSignature()) * scalar;\n                    }\n                    else {\n                        return this._beatsToUnits(4 / numericValue) * scalar;\n                    }\n                },\n                regexp: /^(\\d+)n(\\.?)$/i,\n            },\n            number: {\n                method: (value) => {\n                    return this._expressions[this.defaultUnits].method.call(this, value);\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)$/,\n            },\n            s: {\n                method: (value) => {\n                    return this._secondsToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)s$/,\n            },\n            samples: {\n                method: (value) => {\n                    return parseInt(value, 10) / this.context.sampleRate;\n                },\n                regexp: /^(\\d+)samples$/,\n            },\n            t: {\n                method: (value) => {\n                    const numericValue = parseInt(value, 10);\n                    return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n                },\n                regexp: /^(\\d+)t$/i,\n            },\n            tr: {\n                method: (m, q, s) => {\n                    let total = 0;\n                    if (m && m !== \"0\") {\n                        total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n                    }\n                    if (q && q !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(q));\n                    }\n                    if (s && s !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(s) / 4);\n                    }\n                    return total;\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n            },\n        };\n    }\n    //-------------------------------------\n    // \tVALUE OF\n    //-------------------------------------\n    /**\n     * Evaluate the time value. Returns the time in seconds.\n     */\n    valueOf() {\n        if (this._val instanceof TimeBaseClass) {\n            this.fromType(this._val);\n        }\n        if (isUndef(this._val)) {\n            return this._noArg();\n        }\n        else if (isString(this._val) && isUndef(this._units)) {\n            for (const units in this._expressions) {\n                if (this._expressions[units].regexp.test(this._val.trim())) {\n                    this._units = units;\n                    break;\n                }\n            }\n        }\n        else if (isObject(this._val)) {\n            let total = 0;\n            for (const typeName in this._val) {\n                if (isDefined(this._val[typeName])) {\n                    const quantity = this._val[typeName];\n                    // @ts-ignore\n                    const time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n                    total += time;\n                }\n            }\n            return total;\n        }\n        if (isDefined(this._units)) {\n            const expr = this._expressions[this._units];\n            const matching = this._val.toString().trim().match(expr.regexp);\n            if (matching) {\n                return expr.method.apply(this, matching.slice(1));\n            }\n            else {\n                return expr.method.call(this, this._val);\n            }\n        }\n        else if (isString(this._val)) {\n            return parseFloat(this._val);\n        }\n        else {\n            return this._val;\n        }\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS\n    //-------------------------------------\n    /**\n     * Returns the value of a frequency in the current units\n     */\n    _frequencyToUnits(freq) {\n        return 1 / freq;\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return (60 / this._getBpm()) * beats;\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return seconds;\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return (ticks * (this._beatsToUnits(1)) / this._getPPQ());\n    }\n    /**\n     * With no arguments, return 'now'\n     */\n    _noArg() {\n        return this._now();\n    }\n    //-------------------------------------\n    // \tTEMPO CONVERSIONS\n    //-------------------------------------\n    /**\n     * Return the bpm\n     */\n    _getBpm() {\n        return this.context.transport.bpm.value;\n    }\n    /**\n     * Return the timeSignature\n     */\n    _getTimeSignature() {\n        return this.context.transport.timeSignature;\n    }\n    /**\n     * Return the PPQ or 192 if Transport is not available\n     */\n    _getPPQ() {\n        return this.context.transport.PPQ;\n    }\n    //-------------------------------------\n    // \tCONVERSION INTERFACE\n    //-------------------------------------\n    /**\n     * Coerce a time type into this units type.\n     * @param type Any time type units\n     */\n    fromType(type) {\n        this._units = undefined;\n        switch (this.defaultUnits) {\n            case \"s\":\n                this._val = type.toSeconds();\n                break;\n            case \"i\":\n                this._val = type.toTicks();\n                break;\n            case \"hz\":\n                this._val = type.toFrequency();\n                break;\n            case \"midi\":\n                this._val = type.toMidi();\n                break;\n        }\n        return this;\n    }\n    /**\n     * Return the value in hertz\n     */\n    toFrequency() {\n        return 1 / this.toSeconds();\n    }\n    /**\n     * Return the time in samples\n     */\n    toSamples() {\n        return this.toSeconds() * this.context.sampleRate;\n    }\n    /**\n     * Return the time in milliseconds.\n     */\n    toMilliseconds() {\n        return this.toSeconds() * 1000;\n    }\n}\n//# sourceMappingURL=TimeBase.js.map","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass extends TimeBaseClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"TimeClass\";\n    }\n    _getExpressions() {\n        return Object.assign(super._getExpressions(), {\n            now: {\n                method: (capture) => {\n                    return this._now() + new this.constructor(this.context, capture).valueOf();\n                },\n                regexp: /^\\+(.+)/,\n            },\n            quantize: {\n                method: (capture) => {\n                    const quantTo = new TimeClass(this.context, capture).valueOf();\n                    return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n                },\n                regexp: /^@(.+)/,\n            },\n        });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n    quantize(subdiv, percent = 1) {\n        const subdivision = new this.constructor(this.context, subdiv).valueOf();\n        const value = this.valueOf();\n        const multiple = Math.round(value / subdivision);\n        const ideal = multiple * subdivision;\n        const diff = ideal - value;\n        return value + diff * percent;\n    }\n    //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n    toNotation() {\n        const time = this.toSeconds();\n        const testNotations = [\"1m\"];\n        for (let power = 1; power < 9; power++) {\n            const subdiv = Math.pow(2, power);\n            testNotations.push(subdiv + \"n.\");\n            testNotations.push(subdiv + \"n\");\n            testNotations.push(subdiv + \"t\");\n        }\n        testNotations.push(\"0\");\n        // find the closets notation representation\n        let closest = testNotations[0];\n        let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n        testNotations.forEach(notation => {\n            const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n            if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n                closest = notation;\n                closestSeconds = notationSeconds;\n            }\n        });\n        return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n    toBarsBeatsSixteenths() {\n        const quarterTime = this._beatsToUnits(1);\n        let quarters = this.valueOf() / quarterTime;\n        quarters = parseFloat(quarters.toFixed(4));\n        const measures = Math.floor(quarters / this._getTimeSignature());\n        let sixteenths = (quarters % 1) * 4;\n        quarters = Math.floor(quarters) % this._getTimeSignature();\n        const sixteenthString = sixteenths.toString();\n        if (sixteenthString.length > 3) {\n            // the additional parseFloat removes insignificant trailing zeroes\n            sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n        }\n        const progress = [measures, quarters, sixteenths];\n        return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n    toTicks() {\n        const quarterTime = this._beatsToUnits(1);\n        const quarters = this.valueOf() / quarterTime;\n        return Math.round(quarters * this._getPPQ());\n    }\n    /**\n     * Return the time in seconds.\n     */\n    toSeconds() {\n        return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n    toMidi() {\n        return ftom(this.toFrequency());\n    }\n    _now() {\n        return this.context.now();\n    }\n}\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value, units) {\n    return new TimeClass(getContext(), value, units);\n}\n//# sourceMappingURL=Time.js.map","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `valueOf` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass extends TimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"Frequency\";\n        this.defaultUnits = \"hz\";\n    }\n    /**\n     * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n     * to generate all the other pitch values from notes. A4's values in Hertz.\n     */\n    static get A4() {\n        return getA4();\n    }\n    static set A4(freq) {\n        setA4(freq);\n    }\n    //-------------------------------------\n    // \tAUGMENT BASE EXPRESSIONS\n    //-------------------------------------\n    _getExpressions() {\n        return Object.assign({}, super._getExpressions(), {\n            midi: {\n                regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n                method(value) {\n                    if (this.defaultUnits === \"midi\") {\n                        return value;\n                    }\n                    else {\n                        return FrequencyClass.mtof(value);\n                    }\n                },\n            },\n            note: {\n                regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n                method(pitch, octave) {\n                    const index = noteToScaleIndex[pitch.toLowerCase()];\n                    const noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n                    if (this.defaultUnits === \"midi\") {\n                        return noteNumber;\n                    }\n                    else {\n                        return FrequencyClass.mtof(noteNumber);\n                    }\n                },\n            },\n            tr: {\n                regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n                method(m, q, s) {\n                    let total = 1;\n                    if (m && m !== \"0\") {\n                        total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n                    }\n                    if (q && q !== \"0\") {\n                        total *= this._beatsToUnits(parseFloat(q));\n                    }\n                    if (s && s !== \"0\") {\n                        total *= this._beatsToUnits(parseFloat(s) / 4);\n                    }\n                    return total;\n                },\n            },\n        });\n    }\n    //-------------------------------------\n    // \tEXPRESSIONS\n    //-------------------------------------\n    /**\n     * Transposes the frequency by the given number of semitones.\n     * @return  A new transposed frequency\n     * @example\n     * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n     */\n    transpose(interval) {\n        return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n    }\n    /**\n     * Takes an array of semitone intervals and returns\n     * an array of frequencies transposed by those intervals.\n     * @return  Returns an array of Frequencies\n     * @example\n     * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n     */\n    harmonize(intervals) {\n        return intervals.map(interval => {\n            return this.transpose(interval);\n        });\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS\n    //-------------------------------------\n    /**\n     * Return the value of the frequency as a MIDI note\n     * @example\n     * Tone.Frequency(\"C4\").toMidi(); // 60\n     */\n    toMidi() {\n        return ftom(this.valueOf());\n    }\n    /**\n     * Return the value of the frequency in Scientific Pitch Notation\n     * @example\n     * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n     */\n    toNote() {\n        const freq = this.toFrequency();\n        const log = Math.log2(freq / FrequencyClass.A4);\n        let noteNumber = Math.round(12 * log) + 57;\n        const octave = Math.floor(noteNumber / 12);\n        if (octave < 0) {\n            noteNumber += -12 * octave;\n        }\n        const noteName = scaleIndexToNote[noteNumber % 12];\n        return noteName + octave.toString();\n    }\n    /**\n     * Return the duration of one cycle in seconds.\n     */\n    toSeconds() {\n        return 1 / super.toSeconds();\n    }\n    /**\n     * Return the duration of one cycle in ticks\n     */\n    toTicks() {\n        const quarterTime = this._beatsToUnits(1);\n        const quarters = this.valueOf() / quarterTime;\n        return Math.floor(quarters * this._getPPQ());\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS HELPERS\n    //-------------------------------------\n    /**\n     * With no arguments, return 0\n     */\n    _noArg() {\n        return 0;\n    }\n    /**\n     * Returns the value of a frequency in the current units\n     */\n    _frequencyToUnits(freq) {\n        return freq;\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ()));\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return 1 / super._beatsToUnits(beats);\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return 1 / seconds;\n    }\n    /**\n     * Convert a MIDI note to frequency value.\n     * @param  midi The midi number to convert.\n     * @return The corresponding frequency value\n     */\n    static mtof(midi) {\n        return mtof(midi);\n    }\n    /**\n     * Convert a frequency value to a MIDI note.\n     * @param frequency The value to frequency value to convert.\n     */\n    static ftom(frequency) {\n        return ftom(frequency);\n    }\n}\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n/**\n * Note to scale index.\n * @hidden\n */\nconst noteToScaleIndex = {\n    cbb: -2, cb: -1, c: 0, \"c#\": 1, cx: 2,\n    dbb: 0, db: 1, d: 2, \"d#\": 3, dx: 4,\n    ebb: 2, eb: 3, e: 4, \"e#\": 5, ex: 6,\n    fbb: 3, fb: 4, f: 5, \"f#\": 6, fx: 7,\n    gbb: 5, gb: 6, g: 7, \"g#\": 8, gx: 9,\n    abb: 7, ab: 8, a: 9, \"a#\": 10, ax: 11,\n    bbb: 9, bb: 10, b: 11, \"b#\": 12, bx: 13,\n};\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n * @example\n * const midi = Tone.Frequency(\"C3\").toMidi();\n * console.log(midi);\n * @example\n * const hertz = Tone.Frequency(38, \"midi\").toFrequency();\n * console.log(hertz);\n */\nexport function Frequency(value, units) {\n    return new FrequencyClass(getContext(), value, units);\n}\n//# sourceMappingURL=Frequency.js.map","import { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass extends TimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"TransportTime\";\n    }\n    /**\n     * Return the current time in whichever context is relevant\n     */\n    _now() {\n        return this.context.transport.seconds;\n    }\n}\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value, units) {\n    return new TransportTimeClass(getContext(), value, units);\n}\n//# sourceMappingURL=TransportTime.js.map","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport class ToneWithContext extends Tone {\n    constructor() {\n        super();\n        const options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n        if (this.defaultContext) {\n            this.context = this.defaultContext;\n        }\n        else {\n            this.context = options.context;\n        }\n    }\n    static getDefaults() {\n        return {\n            context: getContext(),\n        };\n    }\n    /**\n     * Return the current time of the Context clock plus the lookAhead.\n     * @example\n     * setInterval(() => {\n     * \tconsole.log(Tone.now());\n     * }, 100);\n     */\n    now() {\n        return this.context.currentTime + this.context.lookAhead;\n    }\n    /**\n     * Return the current time of the Context clock without any lookAhead.\n     * @example\n     * setInterval(() => {\n     * \tconsole.log(Tone.immediate());\n     * }, 100);\n     */\n    immediate() {\n        return this.context.currentTime;\n    }\n    /**\n     * The duration in seconds of one sample.\n     * @example\n     * console.log(Tone.Transport.sampleTime);\n     */\n    get sampleTime() {\n        return 1 / this.context.sampleRate;\n    }\n    /**\n     * The number of seconds of 1 processing block (128 samples)\n     * @example\n     * console.log(Tone.Destination.blockTime);\n     */\n    get blockTime() {\n        return 128 / this.context.sampleRate;\n    }\n    /**\n     * Convert the incoming time to seconds\n     * @example\n     * const gain = new Tone.Gain();\n     * console.log(gain.toSeconds(\"4n\"));\n     */\n    toSeconds(time) {\n        return new TimeClass(this.context, time).toSeconds();\n    }\n    /**\n     * Convert the input to a frequency number\n     * @example\n     * const gain = new Tone.Gain();\n     * console.log(gain.toFrequency(\"4n\"));\n     */\n    toFrequency(freq) {\n        return new FrequencyClass(this.context, freq).toFrequency();\n    }\n    /**\n     * Convert the input time into ticks\n     * @example\n     * const gain = new Tone.Gain();\n     * console.log(gain.toTicks(\"4n\"));\n     */\n    toTicks(time) {\n        return new TransportTimeClass(this.context, time).toTicks();\n    }\n    //-------------------------------------\n    // \tGET/SET\n    //-------------------------------------\n    /**\n     * Get a subset of the properties which are in the partial props\n     */\n    _getPartialProperties(props) {\n        const options = this.get();\n        // remove attributes from the prop that are not in the partial\n        Object.keys(options).forEach(name => {\n            if (isUndef(props[name])) {\n                delete options[name];\n            }\n        });\n        return options;\n    }\n    /**\n     * Get the object's attributes.\n     * @example\n     * const osc = new Tone.Oscillator();\n     * console.log(osc.get());\n     */\n    get() {\n        const defaults = getDefaultsFromInstance(this);\n        Object.keys(defaults).forEach(attribute => {\n            if (Reflect.has(this, attribute)) {\n                const member = this[attribute];\n                if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n                    defaults[attribute] = member.value;\n                }\n                else if (member instanceof ToneWithContext) {\n                    defaults[attribute] = member._getPartialProperties(defaults[attribute]);\n                    // otherwise make sure it's a serializable type\n                }\n                else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n                    defaults[attribute] = member;\n                }\n                else {\n                    // remove all undefined and unserializable attributes\n                    delete defaults[attribute];\n                }\n            }\n        });\n        return defaults;\n    }\n    /**\n     * Set multiple properties at once with an object.\n     * @example\n     * const filter = new Tone.Filter();\n     * // set values using an object\n     * filter.set({\n     * \tfrequency: 300,\n     * \ttype: \"highpass\"\n     * });\n     */\n    set(props) {\n        Object.keys(props).forEach(attribute => {\n            if (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n                if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n                    // small optimization\n                    if (this[attribute].value !== props[attribute]) {\n                        this[attribute].value = props[attribute];\n                    }\n                }\n                else if (this[attribute] instanceof ToneWithContext) {\n                    this[attribute].set(props[attribute]);\n                }\n                else {\n                    this[attribute] = props[attribute];\n                }\n            }\n        });\n        return this;\n    }\n}\n//# sourceMappingURL=ToneWithContext.js.map","import { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline extends Timeline {\n    constructor(initial = \"stopped\") {\n        super();\n        this.name = \"StateTimeline\";\n        this._initial = initial;\n        this.setStateAtTime(this._initial, 0);\n    }\n    /**\n     * Returns the scheduled state scheduled before or at\n     * the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     */\n    getValueAtTime(time) {\n        const event = this.get(time);\n        if (event !== null) {\n            return event.state;\n        }\n        else {\n            return this._initial;\n        }\n    }\n    /**\n     * Add a state to the timeline.\n     * @param  state The name of the state to set.\n     * @param  time  The time to query.\n     * @param options Any additional options that are needed in the timeline.\n     */\n    setStateAtTime(state, time, options) {\n        assertRange(time, 0);\n        this.add(Object.assign({}, options, {\n            state,\n            time,\n        }));\n        return this;\n    }\n    /**\n     * Return the event before the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check before\n     * @return  The event with the given state before the time\n     */\n    getLastState(state, time) {\n        // time = this.toSeconds(time);\n        const index = this._search(time);\n        for (let i = index; i >= 0; i--) {\n            const event = this._timeline[i];\n            if (event.state === state) {\n                return event;\n            }\n        }\n    }\n    /**\n     * Return the event after the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check from\n     * @return  The event with the given state after the time\n     */\n    getNextState(state, time) {\n        // time = this.toSeconds(time);\n        const index = this._search(time);\n        if (index !== -1) {\n            for (let i = index; i < this._timeline.length; i++) {\n                const event = this._timeline[i];\n                if (event.state === state) {\n                    return event;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=StateTimeline.js.map","import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n        this.name = \"Param\";\n        this.overridden = false;\n        /**\n         * The minimum output value\n         */\n        this._minOutput = 1e-7;\n        const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n        assert(isDefined(options.param) &&\n            (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n        while (!isAudioParam(options.param)) {\n            options.param = options.param._param;\n        }\n        this._swappable = isDefined(options.swappable) ? options.swappable : false;\n        if (this._swappable) {\n            this.input = this.context.createGain();\n            // initialize\n            this._param = options.param;\n            this.input.connect(this._param);\n        }\n        else {\n            this._param = this.input = options.param;\n        }\n        this._events = new Timeline(1000);\n        this._initialValue = this._param.defaultValue;\n        this.units = options.units;\n        this.convert = options.convert;\n        this._minValue = options.minValue;\n        this._maxValue = options.maxValue;\n        // if the value is defined, set it immediately\n        if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n            this.setValueAtTime(options.value, 0);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            convert: true,\n            units: \"number\",\n        });\n    }\n    get value() {\n        const now = this.now();\n        return this.getValueAtTime(now);\n    }\n    set value(value) {\n        this.cancelScheduledValues(this.now());\n        this.setValueAtTime(value, this.now());\n    }\n    get minValue() {\n        // if it's not the default minValue, return it\n        if (isDefined(this._minValue)) {\n            return this._minValue;\n        }\n        else if (this.units === \"time\" || this.units === \"frequency\" ||\n            this.units === \"normalRange\" || this.units === \"positive\" ||\n            this.units === \"transportTime\" || this.units === \"ticks\" ||\n            this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n            return 0;\n        }\n        else if (this.units === \"audioRange\") {\n            return -1;\n        }\n        else if (this.units === \"decibels\") {\n            return -Infinity;\n        }\n        else {\n            return this._param.minValue;\n        }\n    }\n    get maxValue() {\n        if (isDefined(this._maxValue)) {\n            return this._maxValue;\n        }\n        else if (this.units === \"normalRange\" ||\n            this.units === \"audioRange\") {\n            return 1;\n        }\n        else {\n            return this._param.maxValue;\n        }\n    }\n    /**\n     * Type guard based on the unit name\n     */\n    _is(arg, type) {\n        return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n    _assertRange(value) {\n        if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n            assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n        }\n        return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n    _fromType(val) {\n        if (this.convert && !this.overridden) {\n            if (this._is(val, \"time\")) {\n                return this.toSeconds(val);\n            }\n            else if (this._is(val, \"decibels\")) {\n                return dbToGain(val);\n            }\n            else if (this._is(val, \"frequency\")) {\n                return this.toFrequency(val);\n            }\n            else {\n                return val;\n            }\n        }\n        else if (this.overridden) {\n            // if it's overridden, should only schedule 0s\n            return 0;\n        }\n        else {\n            return val;\n        }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n    _toType(val) {\n        if (this.convert && this.units === \"decibels\") {\n            return gainToDb(val);\n        }\n        else {\n            return val;\n        }\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        const numericValue = this._fromType(value);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n        this._assertRange(numericValue);\n        this.log(this.units, \"setValueAtTime\", value, computedTime);\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: numericValue,\n        });\n        this._param.setValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    getValueAtTime(time) {\n        const computedTime = Math.max(this.toSeconds(time), 0);\n        const after = this._events.getAfter(computedTime);\n        const before = this._events.get(computedTime);\n        let value = this._initialValue;\n        // if it was set by\n        if (before === null) {\n            value = this._initialValue;\n        }\n        else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n            const previous = this._events.getBefore(before.time);\n            let previousVal;\n            if (previous === null) {\n                previousVal = this._initialValue;\n            }\n            else {\n                previousVal = previous.value;\n            }\n            if (before.type === \"setTargetAtTime\") {\n                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n            }\n        }\n        else if (after === null) {\n            value = before.value;\n        }\n        else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n            let beforeValue = before.value;\n            if (before.type === \"setTargetAtTime\") {\n                const previous = this._events.getBefore(before.time);\n                if (previous === null) {\n                    beforeValue = this._initialValue;\n                }\n                else {\n                    beforeValue = previous.value;\n                }\n            }\n            if (after.type === \"linearRampToValueAtTime\") {\n                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n            else {\n                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n        }\n        else {\n            value = before.value;\n        }\n        return this._toType(value);\n    }\n    setRampPoint(time) {\n        time = this.toSeconds(time);\n        let currentVal = this.getValueAtTime(time);\n        this.cancelAndHoldAtTime(time);\n        if (this._fromType(currentVal) === 0) {\n            currentVal = this._toType(this._minOutput);\n        }\n        this.setValueAtTime(currentVal, time);\n        return this;\n    }\n    linearRampToValueAtTime(value, endTime) {\n        const numericValue = this._fromType(value);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        this._assertRange(numericValue);\n        this._events.add({\n            time: computedTime,\n            type: \"linearRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n        this._param.linearRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, endTime) {\n        let numericValue = this._fromType(value);\n        numericValue = Math.max(this._minOutput, numericValue);\n        this._assertRange(numericValue);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        // store the event\n        this._events.add({\n            time: computedTime,\n            type: \"exponentialRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n        this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialApproachValueAtTime(value, startTime, rampTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        time = this.toSeconds(time);\n        rampTime = this.toSeconds(rampTime);\n        const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n        this.setTargetAtTime(value, time, timeConstant);\n        // at 90% start a linear ramp to the final value\n        this.cancelAndHoldAtTime(time + rampTime * 0.9);\n        this.linearRampToValueAtTime(value, time + rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const numericValue = this._fromType(value);\n        // The value will never be able to approach without timeConstant > 0.\n        assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n        const computedTime = this.toSeconds(startTime);\n        this._assertRange(numericValue);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n        this._events.add({\n            constant: timeConstant,\n            time: computedTime,\n            type: \"setTargetAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n        duration = this.toSeconds(duration);\n        startTime = this.toSeconds(startTime);\n        const startingValue = this._fromType(values[0]) * scaling;\n        this.setValueAtTime(this._toType(startingValue), startTime);\n        const segTime = duration / (values.length - 1);\n        for (let i = 1; i < values.length; i++) {\n            const numericValue = this._fromType(values[i]) * scaling;\n            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n        }\n        return this;\n    }\n    cancelScheduledValues(time) {\n        const computedTime = this.toSeconds(time);\n        assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n        this._events.cancel(computedTime);\n        this._param.cancelScheduledValues(computedTime);\n        this.log(this.units, \"cancelScheduledValues\", computedTime);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n        // remove the schedule events\n        assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n        this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n        // if there is an event at the given computedTime\n        // and that even is not a \"set\"\n        const before = this._events.get(computedTime);\n        const after = this._events.getAfter(computedTime);\n        if (before && EQ(before.time, computedTime)) {\n            // remove everything after\n            if (after) {\n                this._param.cancelScheduledValues(after.time);\n                this._events.cancel(after.time);\n            }\n            else {\n                this._param.cancelAndHoldAtTime(computedTime);\n                this._events.cancel(computedTime + this.sampleTime);\n            }\n        }\n        else if (after) {\n            this._param.cancelScheduledValues(after.time);\n            // cancel the next event(s)\n            this._events.cancel(after.time);\n            if (after.type === \"linearRampToValueAtTime\") {\n                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n            else if (after.type === \"exponentialRampToValueAtTime\") {\n                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n        }\n        // set the value at the given time\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: valueAtTime,\n        });\n        this._param.setValueAtTime(valueAtTime, computedTime);\n        return this;\n    }\n    rampTo(value, rampTime = 0.1, startTime) {\n        if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n            this.exponentialRampTo(value, rampTime, startTime);\n        }\n        else {\n            this.linearRampTo(value, rampTime, startTime);\n        }\n        return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n    apply(param) {\n        const now = this.context.currentTime;\n        // set the param's value at the current time and schedule everything else\n        param.setValueAtTime(this.getValueAtTime(now), now);\n        // if the previous event was a curve, then set the rest of it\n        const previousEvent = this._events.get(now);\n        if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n            // approx it until the next event with linear ramps\n            const nextEvent = this._events.getAfter(previousEvent.time);\n            // or for 2 seconds if there is no event\n            const endTime = nextEvent ? nextEvent.time : now + 2;\n            const subdivisions = (endTime - now) / 10;\n            for (let i = now; i < endTime; i += subdivisions) {\n                param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n            }\n        }\n        this._events.forEachAfter(this.context.currentTime, event => {\n            if (event.type === \"cancelScheduledValues\") {\n                param.cancelScheduledValues(event.time);\n            }\n            else if (event.type === \"setTargetAtTime\") {\n                param.setTargetAtTime(event.value, event.time, event.constant);\n            }\n            else {\n                param[event.type](event.value, event.time);\n            }\n        });\n        return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n    setParam(param) {\n        assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n        const input = this.input;\n        input.disconnect(this._param);\n        this.apply(param);\n        this._param = param;\n        input.connect(this._param);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        return this;\n    }\n    get defaultValue() {\n        return this._toType(this._param.defaultValue);\n    }\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    _exponentialApproach(t0, v0, v1, timeConstant, t) {\n        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    }\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n    _linearInterpolate(t0, v0, t1, v1, t) {\n        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    }\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n    _exponentialInterpolate(t0, v0, t1, v1, t) {\n        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n}\n//# sourceMappingURL=Param.js.map","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport class ToneAudioNode extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the class\n         */\n        this.name = \"ToneAudioNode\";\n        /**\n         * List all of the node that must be set to match the ChannelProperties\n         */\n        this._internalChannels = [];\n    }\n    /**\n     * The number of inputs feeding into the AudioNode.\n     * For source nodes, this will be 0.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfInputs);\n     */\n    get numberOfInputs() {\n        if (isDefined(this.input)) {\n            if (isAudioParam(this.input) || this.input instanceof Param) {\n                return 1;\n            }\n            else {\n                return this.input.numberOfInputs;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n    get numberOfOutputs() {\n        if (isDefined(this.output)) {\n            return this.output.numberOfOutputs;\n        }\n        else {\n            return 0;\n        }\n    }\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    _isAudioNode(node) {\n        return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n    _getInternalNodes() {\n        const nodeList = this._internalChannels.slice(0);\n        if (this._isAudioNode(this.input)) {\n            nodeList.push(this.input);\n        }\n        if (this._isAudioNode(this.output)) {\n            if (this.input !== this.output) {\n                nodeList.push(this.output);\n            }\n        }\n        return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n    _setChannelProperties(options) {\n        const nodeList = this._getInternalNodes();\n        nodeList.forEach(node => {\n            node.channelCount = options.channelCount;\n            node.channelCountMode = options.channelCountMode;\n            node.channelInterpretation = options.channelInterpretation;\n        });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n    _getChannelProperties() {\n        const nodeList = this._getInternalNodes();\n        assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n        // use the first node to get properties\n        // they should all be the same\n        const node = nodeList[0];\n        return {\n            channelCount: node.channelCount,\n            channelCountMode: node.channelCountMode,\n            channelInterpretation: node.channelInterpretation,\n        };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n    get channelCount() {\n        return this._getChannelProperties().channelCount;\n    }\n    set channelCount(channelCount) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCount }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n    get channelCountMode() {\n        return this._getChannelProperties().channelCountMode;\n    }\n    set channelCountMode(channelCountMode) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCountMode }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n    get channelInterpretation() {\n        return this._getChannelProperties().channelInterpretation;\n    }\n    set channelInterpretation(channelInterpretation) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelInterpretation }));\n    }\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n    toDestination() {\n        this.connect(this.context.destination);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n    toMaster() {\n        warn(\"toMaster() has been renamed toDestination()\");\n        return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n    disconnect(destination, outputNum = 0, inputNum = 0) {\n        disconnect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n    chain(...nodes) {\n        connectSeries(this, ...nodes);\n        return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n    fan(...nodes) {\n        nodes.forEach(node => this.connect(node));\n        return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n    dispose() {\n        super.dispose();\n        if (isDefined(this.input)) {\n            if (this.input instanceof ToneAudioNode) {\n                this.input.dispose();\n            }\n            else if (isAudioNode(this.input)) {\n                this.input.disconnect();\n            }\n        }\n        if (isDefined(this.output)) {\n            if (this.output instanceof ToneAudioNode) {\n                this.output.dispose();\n            }\n            else if (isAudioNode(this.output)) {\n                this.output.disconnect();\n            }\n        }\n        this._internalChannels = [];\n        return this;\n    }\n}\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes) {\n    const first = nodes.shift();\n    nodes.reduce((prev, current) => {\n        if (prev instanceof ToneAudioNode) {\n            prev.connect(current);\n        }\n        else if (isAudioNode(prev)) {\n            connect(prev, current);\n        }\n        return current;\n    }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n    assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n    if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n        assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n    }\n    assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n    // resolve the input of the dstNode\n    while ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n        if (isDefined(dstNode.input)) {\n            dstNode = dstNode.input;\n        }\n    }\n    while (srcNode instanceof ToneAudioNode) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    // make the connection\n    if (isAudioParam(dstNode)) {\n        srcNode.connect(dstNode, outputNumber);\n    }\n    else {\n        srcNode.connect(dstNode, outputNumber, inputNumber);\n    }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    // resolve the destination node\n    if (isDefined(dstNode)) {\n        while (dstNode instanceof ToneAudioNode) {\n            dstNode = dstNode.input;\n        }\n    }\n    // resolve the src node\n    while (!(isAudioNode(srcNode))) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    if (isAudioParam(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber);\n    }\n    else if (isAudioNode(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber, inputNumber);\n    }\n    else {\n        srcNode.disconnect();\n    }\n}\n//# sourceMappingURL=ToneAudioNode.js.map","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @offline 0.7 1\n * @example\n * const gainNode = new Tone.Gain(0).toDestination();\n * const osc = new Tone.Oscillator(30).connect(gainNode).start();\n * gainNode.gain.rampTo(1, 0.1);\n * gainNode.gain.rampTo(0, 0.4, 0.2);\n */\nexport class Gain extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n        this.name = \"Gain\";\n        /**\n         * The wrapped GainNode.\n         */\n        this._gainNode = this.context.createGain();\n        // input = output\n        this.input = this._gainNode;\n        this.output = this._gainNode;\n        const options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n        this.gain = new Param({\n            context: this.context,\n            convert: options.convert,\n            param: this._gainNode.gain,\n            units: options.units,\n            value: options.gain,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n        readOnly(this, \"gain\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            convert: true,\n            gain: 1,\n            units: \"gain\",\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._gainNode.disconnect();\n        this.gain.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Gain.js.map","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Base class for fire-and-forget nodes\n */\nexport class OneShotSource extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * The callback to invoke after the\n         * source is done playing.\n         */\n        this.onended = noOp;\n        /**\n         * The start time\n         */\n        this._startTime = -1;\n        /**\n         * The stop time\n         */\n        this._stopTime = -1;\n        /**\n         * The id of the timeout\n         */\n        this._timeout = -1;\n        /**\n         * The public output node\n         */\n        this.output = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        /**\n         * The output gain node.\n         */\n        this._gainNode = this.output;\n        /**\n         * Get the playback state at the given time\n         */\n        this.getStateAtTime = function (time) {\n            const computedTime = this.toSeconds(time);\n            if (this._startTime !== -1 && computedTime >= this._startTime &&\n                (this._stopTime === -1 || computedTime <= this._stopTime)) {\n                return \"started\";\n            }\n            else {\n                return \"stopped\";\n            }\n        };\n        this._fadeIn = options.fadeIn;\n        this._fadeOut = options.fadeOut;\n        this._curve = options.curve;\n        this.onended = options.onended;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            curve: \"linear\",\n            fadeIn: 0,\n            fadeOut: 0,\n            onended: noOp,\n        });\n    }\n    /**\n     * Start the source at the given time\n     * @param  time When to start the source\n     */\n    _startGain(time, gain = 1) {\n        assert(this._startTime === -1, \"Source cannot be started more than once\");\n        // apply a fade in envelope\n        const fadeInTime = this.toSeconds(this._fadeIn);\n        // record the start time\n        this._startTime = time + fadeInTime;\n        this._startTime = Math.max(this._startTime, this.context.currentTime);\n        // schedule the envelope\n        if (fadeInTime > 0) {\n            this._gainNode.gain.setValueAtTime(0, time);\n            if (this._curve === \"linear\") {\n                this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n            }\n            else {\n                this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n            }\n        }\n        else {\n            this._gainNode.gain.setValueAtTime(gain, time);\n        }\n        return this;\n    }\n    /**\n     * Stop the source node at the given time.\n     * @param time When to stop the source\n     */\n    stop(time) {\n        this.log(\"stop\", time);\n        this._stopGain(this.toSeconds(time));\n        return this;\n    }\n    /**\n     * Stop the source at the given time\n     * @param  time When to stop the source\n     */\n    _stopGain(time) {\n        assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n        // cancel the previous stop\n        this.cancelStop();\n        // the fadeOut time\n        const fadeOutTime = this.toSeconds(this._fadeOut);\n        // schedule the stop callback\n        this._stopTime = this.toSeconds(time) + fadeOutTime;\n        this._stopTime = Math.max(this._stopTime, this.context.currentTime);\n        if (fadeOutTime > 0) {\n            // start the fade out curve at the given time\n            if (this._curve === \"linear\") {\n                this._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n            }\n            else {\n                this._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n            }\n        }\n        else {\n            // stop any ongoing ramps, and set the value to 0\n            this._gainNode.gain.cancelAndHoldAtTime(time);\n            this._gainNode.gain.setValueAtTime(0, time);\n        }\n        this.context.clearTimeout(this._timeout);\n        this._timeout = this.context.setTimeout(() => {\n            // allow additional time for the exponential curve to fully decay\n            const additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n            this._stopSource(this.now() + additionalTail);\n            this._onended();\n        }, this._stopTime - this.context.currentTime);\n        return this;\n    }\n    /**\n     * Invoke the onended callback\n     */\n    _onended() {\n        if (this.onended !== noOp) {\n            this.onended(this);\n            // overwrite onended to make sure it only is called once\n            this.onended = noOp;\n            // dispose when it's ended to free up for garbage collection only in the online context\n            if (!this.context.isOffline) {\n                setTimeout(() => this.dispose(), 1000);\n            }\n        }\n    }\n    /**\n     * Get the playback state at the current time\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Cancel a scheduled stop event\n     */\n    cancelStop() {\n        this.log(\"cancelStop\");\n        assert(this._startTime !== -1, \"Source is not started\");\n        // cancel the stop envelope\n        this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n        this.context.clearTimeout(this._timeout);\n        this._stopTime = -1;\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._gainNode.disconnect();\n        return this;\n    }\n}\n//# sourceMappingURL=OneShotSource.js.map","import { connect } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource } from \"../source/OneShotSource\";\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource extends OneShotSource {\n    constructor() {\n        super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n        this.name = \"ToneConstantSource\";\n        /**\n         * The signal generator\n         */\n        this._source = this.context.createConstantSource();\n        const options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n        connect(this._source, this._gainNode);\n        this.offset = new Param({\n            context: this.context,\n            convert: options.convert,\n            param: this._source.offset,\n            units: options.units,\n            value: options.offset,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            convert: true,\n            offset: 1,\n            units: \"number\",\n        });\n    }\n    /**\n     * Start the source node at the given time\n     * @param  time When to start the source\n     */\n    start(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        this._startGain(computedTime);\n        this._source.start(computedTime);\n        return this;\n    }\n    _stopSource(time) {\n        this._source.stop(time);\n    }\n    dispose() {\n        super.dispose();\n        if (this.state === \"started\") {\n            this.stop();\n        }\n        this._source.disconnect();\n        this.offset.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneConstantSource.js.map","import { Param } from \"../core/context/Param\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n        this.name = \"Signal\";\n        /**\n         * Indicates if the value should be overridden on connection.\n         */\n        this.override = true;\n        const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n        this.output = this._constantSource = new ToneConstantSource({\n            context: this.context,\n            convert: options.convert,\n            offset: options.value,\n            units: options.units,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n        this._constantSource.start(0);\n        this.input = this._param = this._constantSource.offset;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            convert: true,\n            units: \"number\",\n            value: 0,\n        });\n    }\n    connect(destination, outputNum = 0, inputNum = 0) {\n        // start it only when connected to something\n        connectSignal(this, destination, outputNum, inputNum);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._param.dispose();\n        this._constantSource.dispose();\n        return this;\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // just a proxy for the ConstantSourceNode's offset AudioParam\n    // all docs are generated from AbstractParam.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        this._param.setValueAtTime(value, time);\n        return this;\n    }\n    getValueAtTime(time) {\n        return this._param.getValueAtTime(time);\n    }\n    setRampPoint(time) {\n        this._param.setRampPoint(time);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        this._param.linearRampToValueAtTime(value, time);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        this._param.exponentialRampToValueAtTime(value, time);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        this._param.exponentialRampTo(value, rampTime, startTime);\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        this._param.linearRampTo(value, rampTime, startTime);\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        this._param.targetRampTo(value, rampTime, startTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        this._param.exponentialApproachValueAtTime(value, time, rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        this._param.setTargetAtTime(value, startTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling) {\n        this._param.setValueCurveAtTime(values, startTime, duration, scaling);\n        return this;\n    }\n    cancelScheduledValues(time) {\n        this._param.cancelScheduledValues(time);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        this._param.cancelAndHoldAtTime(time);\n        return this;\n    }\n    rampTo(value, rampTime, startTime) {\n        this._param.rampTo(value, rampTime, startTime);\n        return this;\n    }\n    get value() {\n        return this._param.value;\n    }\n    set value(value) {\n        this._param.value = value;\n    }\n    get convert() {\n        return this._param.convert;\n    }\n    set convert(convert) {\n        this._param.convert = convert;\n    }\n    get units() {\n        return this._param.units;\n    }\n    get overridden() {\n        return this._param.overridden;\n    }\n    set overridden(overridden) {\n        this._param.overridden = overridden;\n    }\n    get maxValue() {\n        return this._param.maxValue;\n    }\n    get minValue() {\n        return this._param.minValue;\n    }\n    /**\n     * See [[Param.apply]].\n     */\n    apply(param) {\n        this._param.apply(param);\n        return this;\n    }\n}\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal, destination, outputNum, inputNum) {\n    if (destination instanceof Param || isAudioParam(destination) ||\n        (destination instanceof Signal && destination.override)) {\n        // cancel changes\n        destination.cancelScheduledValues(0);\n        // reset the value\n        destination.setValueAtTime(0, 0);\n        // mark the value as overridden\n        if (destination instanceof Signal) {\n            destination.overridden = true;\n        }\n    }\n    connect(signal, destination, outputNum, inputNum);\n}\n//# sourceMappingURL=Signal.js.map","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam extends Param {\n    constructor() {\n        super(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n        this.name = \"TickParam\";\n        /**\n         * The timeline which tracks all of the automations.\n         */\n        this._events = new Timeline(Infinity);\n        /**\n         * The internal holder for the multiplier value\n         */\n        this._multiplier = 1;\n        const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n        // set the multiplier\n        this._multiplier = options.multiplier;\n        // clear the ticks from the beginning\n        this._events.cancel(0);\n        // set an initial event\n        this._events.add({\n            ticks: 0,\n            time: 0,\n            type: \"setValueAtTime\",\n            value: this._fromType(options.value),\n        });\n        this.setValueAtTime(options.value, 0);\n    }\n    static getDefaults() {\n        return Object.assign(Param.getDefaults(), {\n            multiplier: 1,\n            units: \"hertz\",\n            value: 1,\n        });\n    }\n    setTargetAtTime(value, time, constant) {\n        // approximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        this.setRampPoint(time);\n        const computedValue = this._fromType(value);\n        // start from previously scheduled value\n        const prevEvent = this._events.get(time);\n        const segments = Math.round(Math.max(1 / constant, 1));\n        for (let i = 0; i <= segments; i++) {\n            const segTime = constant * i + time;\n            const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    }\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        super.setValueAtTime(value, time);\n        const event = this._events.get(computedTime);\n        const previousEvent = this._events.previousEvent(event);\n        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        super.linearRampToValueAtTime(value, time);\n        const event = this._events.get(computedTime);\n        const previousEvent = this._events.previousEvent(event);\n        const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n        event.ticks = Math.max(ticksUntilTime, 0);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        // aproximate it with multiple linear ramps\n        time = this.toSeconds(time);\n        const computedVal = this._fromType(value);\n        // start from previously scheduled value\n        const prevEvent = this._events.get(time);\n        // approx 10 segments per second\n        const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n        const segmentDur = ((time - prevEvent.time) / segments);\n        for (let i = 0; i <= segments; i++) {\n            const segTime = segmentDur * i + prevEvent.time;\n            const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n            this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n        }\n        return this;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  event The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    _getTicksUntilEvent(event, time) {\n        if (event === null) {\n            event = {\n                ticks: 0,\n                time: 0,\n                type: \"setValueAtTime\",\n                value: 0,\n            };\n        }\n        else if (isUndef(event.ticks)) {\n            const previousEvent = this._events.previousEvent(event);\n            event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n        }\n        const val0 = this._fromType(this.getValueAtTime(event.time));\n        let val1 = this._fromType(this.getValueAtTime(time));\n        // if it's right on the line, take the previous value\n        const onTheLineEvent = this._events.get(time);\n        if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n            val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n        }\n        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  time The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const event = this._events.get(computedTime);\n        return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n    }\n    /**\n     * Return the elapsed time of the number of ticks from the given time\n     * @param ticks The number of ticks to calculate\n     * @param  time The time to get the next tick from\n     * @return The duration of the number of ticks from the given time in seconds\n     */\n    getDurationOfTicks(ticks, time) {\n        const computedTime = this.toSeconds(time);\n        const currentTick = this.getTicksAtTime(time);\n        return this.getTimeOfTick(currentTick + ticks) - computedTime;\n    }\n    /**\n     * Given a tick, returns the time that tick occurs at.\n     * @return The time that the tick occurs.\n     */\n    getTimeOfTick(tick) {\n        const before = this._events.get(tick, \"ticks\");\n        const after = this._events.getAfter(tick, \"ticks\");\n        if (before && before.ticks === tick) {\n            return before.time;\n        }\n        else if (before && after &&\n            after.type === \"linearRampToValueAtTime\" &&\n            before.value !== after.value) {\n            const val0 = this._fromType(this.getValueAtTime(before.time));\n            const val1 = this._fromType(this.getValueAtTime(after.time));\n            const delta = (val1 - val0) / (after.time - before.time);\n            const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n            const sol1 = (-val0 + k) / delta;\n            const sol2 = (-val0 - k) / delta;\n            return (sol1 > 0 ? sol1 : sol2) + before.time;\n        }\n        else if (before) {\n            if (before.value === 0) {\n                return Infinity;\n            }\n            else {\n                return before.time + (tick - before.ticks) / before.value;\n            }\n        }\n        else {\n            return tick / this._initialValue;\n        }\n    }\n    /**\n     * Convert some number of ticks their the duration in seconds accounting\n     * for any automation curves starting at the given time.\n     * @param  ticks The number of ticks to convert to seconds.\n     * @param  when  When along the automation timeline to convert the ticks.\n     * @return The duration in seconds of the ticks.\n     */\n    ticksToTime(ticks, when) {\n        return this.getDurationOfTicks(ticks, when);\n    }\n    /**\n     * The inverse of [[ticksToTime]]. Convert a duration in\n     * seconds to the corresponding number of ticks accounting for any\n     * automation curves starting at the given time.\n     * @param  duration The time interval to convert to ticks.\n     * @param  when When along the automation timeline to convert the ticks.\n     * @return The duration in ticks.\n     */\n    timeToTicks(duration, when) {\n        const computedTime = this.toSeconds(when);\n        const computedDuration = this.toSeconds(duration);\n        const startTicks = this.getTicksAtTime(computedTime);\n        const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n        return endTicks - startTicks;\n    }\n    /**\n     * Convert from the type when the unit value is BPM\n     */\n    _fromType(val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return 1 / (60 / val / this.multiplier);\n        }\n        else {\n            return super._fromType(val);\n        }\n    }\n    /**\n     * Special case of type conversion where the units === \"bpm\"\n     */\n    _toType(val) {\n        if (this.units === \"bpm\" && this.multiplier) {\n            return (val / this.multiplier) * 60;\n        }\n        else {\n            return super._toType(val);\n        }\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n    get multiplier() {\n        return this._multiplier;\n    }\n    set multiplier(m) {\n        // get and reset the current value with the new multiplier\n        // might be necessary to clear all the previous values\n        const currentVal = this.value;\n        this._multiplier = m;\n        this.cancelScheduledValues(0);\n        this.setValueAtTime(currentVal, 0);\n    }\n}\n//# sourceMappingURL=TickParam.js.map","import { Signal } from \"../../signal/Signal\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal extends Signal {\n    constructor() {\n        super(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n        this.name = \"TickSignal\";\n        const options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n        this.input = this._param = new TickParam({\n            context: this.context,\n            convert: options.convert,\n            multiplier: options.multiplier,\n            param: this._constantSource.offset,\n            units: options.units,\n            value: options.value,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            multiplier: 1,\n            units: \"hertz\",\n            value: 1,\n        });\n    }\n    ticksToTime(ticks, when) {\n        return this._param.ticksToTime(ticks, when);\n    }\n    timeToTicks(duration, when) {\n        return this._param.timeToTicks(duration, when);\n    }\n    getTimeOfTick(tick) {\n        return this._param.getTimeOfTick(tick);\n    }\n    getDurationOfTicks(ticks, time) {\n        return this._param.getDurationOfTicks(ticks, time);\n    }\n    getTicksAtTime(time) {\n        return this._param.getTicksAtTime(time);\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n    get multiplier() {\n        return this._param.multiplier;\n    }\n    set multiplier(m) {\n        this._param.multiplier = m;\n    }\n    dispose() {\n        super.dispose();\n        this._param.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSignal.js.map","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n        this.name = \"TickSource\";\n        /**\n         * The state timeline\n         */\n        this._state = new StateTimeline();\n        /**\n         * The offset values of the ticks\n         */\n        this._tickOffset = new Timeline();\n        const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n        this.frequency = new TickSignal({\n            context: this.context,\n            units: options.units,\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        // set the initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // add the first event\n        this.setTicksAtTime(0, 0);\n    }\n    static getDefaults() {\n        return Object.assign({\n            frequency: 1,\n            units: \"hertz\",\n        }, ToneWithContext.getDefaults());\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    start(time, offset) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (isDefined(offset)) {\n                this.setTicksAtTime(offset, computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        // cancel the previous stop\n        if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n            const event = this._state.get(computedTime);\n            if (event && event.time > 0) {\n                this._tickOffset.cancel(event.time);\n                this._state.cancel(event.time);\n            }\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this.setTicksAtTime(0, computedTime);\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n    cancel(time) {\n        time = this.toSeconds(time);\n        this._state.cancel(time);\n        this._tickOffset.cancel(time);\n        return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time: computedTime };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedTicks = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedTicks = offsetEvent.ticks;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n    get ticks() {\n        return this.getTicksAtTime(this.now());\n    }\n    set ticks(t) {\n        this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n    get seconds() {\n        return this.getSecondsAtTime(this.now());\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this.frequency.timeToTicks(s, now);\n        this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        time = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", time);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedSeconds = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedSeconds = offsetEvent.seconds;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedSeconds += e.time - periodStartTime;\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        time = this.toSeconds(time);\n        this._tickOffset.cancel(time);\n        this._tickOffset.add({\n            seconds: this.frequency.getDurationOfTicks(ticks, time),\n            ticks,\n            time,\n        });\n        return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n    getStateAtTime(time) {\n        time = this.toSeconds(time);\n        return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        const offset = this._tickOffset.get(before);\n        const event = this._state.get(before);\n        const startTime = Math.max(offset.time, event.time);\n        const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n        return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n    forEachTickBetween(startTime, endTime, callback) {\n        // only iterate through the sections where it is \"started\"\n        let lastStateEvent = this._state.get(startTime);\n        this._state.forEachBetween(startTime, endTime, event => {\n            if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n                this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n            }\n            lastStateEvent = event;\n        });\n        let error = null;\n        if (lastStateEvent && lastStateEvent.state === \"started\") {\n            const maxStartTime = Math.max(lastStateEvent.time, startTime);\n            // figure out the difference between the frequency ticks and the\n            const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n            const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n            const diff = startTicks - ticksAtStart;\n            let offset = Math.ceil(diff) - diff;\n            // guard against floating point issues\n            offset = EQ(offset, 1) ? 0 : offset;\n            let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n            while (nextTickTime < endTime) {\n                try {\n                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n                }\n                catch (e) {\n                    error = e;\n                    break;\n                }\n                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n            }\n        }\n        if (error) {\n            throw error;\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._state.dispose();\n        this._tickOffset.dispose();\n        this.frequency.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSource.js.map","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n        this.name = \"Clock\";\n        /**\n         * The callback function to invoke at the scheduled tick.\n         */\n        this.callback = noOp;\n        /**\n         * The last time the loop callback was invoked\n         */\n        this._lastUpdate = 0;\n        /**\n         * Keep track of the playback state\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * Context bound reference to the _loop method\n         * This is necessary to remove the event in the end.\n         */\n        this._boundLoop = this._loop.bind(this);\n        const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n        this.callback = options.callback;\n        this._tickSource = new TickSource({\n            context: this.context,\n            frequency: options.frequency,\n            units: options.units,\n        });\n        this._lastUpdate = 0;\n        this.frequency = this._tickSource.frequency;\n        readOnly(this, \"frequency\");\n        // add an initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // bind a callback to the worker thread\n        this.context.on(\"tick\", this._boundLoop);\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            frequency: 1,\n            units: \"hertz\",\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    start(time, offset) {\n        // make sure the context is running\n        assertContextRunning(this.context);\n        // start the loop\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            this._tickSource.start(computedTime, offset);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"start\", computedTime, offset);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"stop\", computedTime);\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this._tickSource.stop(computedTime);\n        if (computedTime < this._lastUpdate) {\n            this.emit(\"stop\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._tickSource.pause(computedTime);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"pause\", computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n    get ticks() {\n        return Math.ceil(this.getTicksAtTime(this.now()));\n    }\n    set ticks(t) {\n        this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n    get seconds() {\n        return this._tickSource.seconds;\n    }\n    set seconds(s) {\n        this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        this._tickSource.setTicksAtTime(ticks, time);\n        return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n    nextTickTime(offset, when) {\n        const computedTime = this.toSeconds(when);\n        const currentTick = this.getTicksAtTime(computedTime);\n        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n    _loop() {\n        const startTime = this._lastUpdate;\n        const endTime = this.now();\n        this._lastUpdate = endTime;\n        this.log(\"loop\", startTime, endTime);\n        if (startTime !== endTime) {\n            // the state change events\n            this._state.forEachBetween(startTime, endTime, e => {\n                switch (e.state) {\n                    case \"started\":\n                        const offset = this._tickSource.getTicksAtTime(e.time);\n                        this.emit(\"start\", e.time, offset);\n                        break;\n                    case \"stopped\":\n                        if (e.time !== 0) {\n                            this.emit(\"stop\", e.time);\n                        }\n                        break;\n                    case \"paused\":\n                        this.emit(\"pause\", e.time);\n                        break;\n                }\n            });\n            // the tick callbacks\n            this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n                this.callback(time, ticks);\n            });\n        }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n    getStateAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.context.off(\"tick\", this._boundLoop);\n        this._tickSource.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Clock);\n//# sourceMappingURL=Clock.js.map","import { Timeline } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue extends Tone {\n    /**\n     * @param initialValue The value to return if there is no scheduled values\n     */\n    constructor(initialValue) {\n        super();\n        this.name = \"TimelineValue\";\n        /**\n         * The timeline which stores the values\n         */\n        this._timeline = new Timeline({ memory: 10 });\n        this._initialValue = initialValue;\n    }\n    /**\n     * Set the value at the given time\n     */\n    set(value, time) {\n        this._timeline.add({\n            value, time\n        });\n        return this;\n    }\n    /**\n     * Get the value at the given time\n     */\n    get(time) {\n        const event = this._timeline.get(time);\n        if (event) {\n            return event.value;\n        }\n        else {\n            return this._initialValue;\n        }\n    }\n}\n//# sourceMappingURL=TimelineValue.js.map","import { getContext } from \"../Global\";\nimport { TransportTimeClass } from \"./TransportTime\";\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"Ticks\";\n        this.defaultUnits = \"i\";\n    }\n    /**\n     * Get the current time in the given units\n     */\n    _now() {\n        return this.context.transport.ticks;\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return this._getPPQ() * beats;\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return ticks;\n    }\n    /**\n     * Return the time in ticks\n     */\n    toTicks() {\n        return this.valueOf();\n    }\n    /**\n     * Return the time in seconds\n     */\n    toSeconds() {\n        return (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n    }\n}\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value, units) {\n    return new TicksClass(getContext(), value, units);\n}\n//# sourceMappingURL=Ticks.js.map","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"IntervalTimeline\";\n        /**\n         * The root node of the inteval tree\n         */\n        this._root = null;\n        /**\n         * Keep track of the length of the timeline.\n         */\n        this._length = 0;\n    }\n    /**\n     * The event to add to the timeline. All events must\n     * have a time and duration value\n     * @param  event  The event to add to the timeline\n     */\n    add(event) {\n        assert(isDefined(event.time), \"Events must have a time property\");\n        assert(isDefined(event.duration), \"Events must have a duration parameter\");\n        event.time = event.time.valueOf();\n        let node = new IntervalNode(event.time, event.time + event.duration, event);\n        if (this._root === null) {\n            this._root = node;\n        }\n        else {\n            this._root.insert(node);\n        }\n        this._length++;\n        // Restructure tree to be balanced\n        while (node !== null) {\n            node.updateHeight();\n            node.updateMax();\n            this._rebalance(node);\n            node = node.parent;\n        }\n        return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  event  The event to remove from the timeline\n     */\n    remove(event) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(event.time, results);\n            for (const node of results) {\n                if (node.event === event) {\n                    this._removeNode(node);\n                    this._length--;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of items in the timeline.\n     * @readOnly\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Remove events whose time time is after the given time\n     * @param  after  The time to query.\n     */\n    cancel(after) {\n        this.forEachFrom(after, event => this.remove(event));\n        return this;\n    }\n    /**\n     * Set the root node as the given node\n     */\n    _setRoot(node) {\n        this._root = node;\n        if (this._root !== null) {\n            this._root.parent = null;\n        }\n    }\n    /**\n     * Replace the references to the node in the node's parent\n     * with the replacement node.\n     */\n    _replaceNodeInParent(node, replacement) {\n        if (node.parent !== null) {\n            if (node.isLeftChild()) {\n                node.parent.left = replacement;\n            }\n            else {\n                node.parent.right = replacement;\n            }\n            this._rebalance(node.parent);\n        }\n        else {\n            this._setRoot(replacement);\n        }\n    }\n    /**\n     * Remove the node from the tree and replace it with\n     * a successor which follows the schema.\n     */\n    _removeNode(node) {\n        if (node.left === null && node.right === null) {\n            this._replaceNodeInParent(node, null);\n        }\n        else if (node.right === null) {\n            this._replaceNodeInParent(node, node.left);\n        }\n        else if (node.left === null) {\n            this._replaceNodeInParent(node, node.right);\n        }\n        else {\n            const balance = node.getBalance();\n            let replacement;\n            let temp = null;\n            if (balance > 0) {\n                if (node.left.right === null) {\n                    replacement = node.left;\n                    replacement.right = node.right;\n                    temp = replacement;\n                }\n                else {\n                    replacement = node.left.right;\n                    while (replacement.right !== null) {\n                        replacement = replacement.right;\n                    }\n                    if (replacement.parent) {\n                        replacement.parent.right = replacement.left;\n                        temp = replacement.parent;\n                        replacement.left = node.left;\n                        replacement.right = node.right;\n                    }\n                }\n            }\n            else if (node.right.left === null) {\n                replacement = node.right;\n                replacement.left = node.left;\n                temp = replacement;\n            }\n            else {\n                replacement = node.right.left;\n                while (replacement.left !== null) {\n                    replacement = replacement.left;\n                }\n                if (replacement.parent) {\n                    replacement.parent.left = replacement.right;\n                    temp = replacement.parent;\n                    replacement.left = node.left;\n                    replacement.right = node.right;\n                }\n            }\n            if (node.parent !== null) {\n                if (node.isLeftChild()) {\n                    node.parent.left = replacement;\n                }\n                else {\n                    node.parent.right = replacement;\n                }\n            }\n            else {\n                this._setRoot(replacement);\n            }\n            if (temp) {\n                this._rebalance(temp);\n            }\n        }\n        node.dispose();\n    }\n    /**\n     * Rotate the tree to the left\n     */\n    _rotateLeft(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.right the new root of this sub tree (instead of node)\n        const pivotNode = node.right;\n        if (pivotNode) {\n            node.right = pivotNode.left;\n            pivotNode.left = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Rotate the tree to the right\n     */\n    _rotateRight(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.left the new root of this sub tree (instead of node)\n        const pivotNode = node.left;\n        if (pivotNode) {\n            node.left = pivotNode.right;\n            pivotNode.right = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Balance the BST\n     */\n    _rebalance(node) {\n        const balance = node.getBalance();\n        if (balance > 1 && node.left) {\n            if (node.left.getBalance() < 0) {\n                this._rotateLeft(node.left);\n            }\n            else {\n                this._rotateRight(node);\n            }\n        }\n        else if (balance < -1 && node.right) {\n            if (node.right.getBalance() > 0) {\n                this._rotateRight(node.right);\n            }\n            else {\n                this._rotateLeft(node);\n            }\n        }\n    }\n    /**\n     * Get an event whose time and duration span the give time. Will\n     * return the match whose \"time\" value is closest to the given time.\n     * @return  The event which spans the desired time\n     */\n    get(time) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            if (results.length > 0) {\n                let max = results[0];\n                for (let i = 1; i < results.length; i++) {\n                    if (results[i].low > max.low) {\n                        max = results[i];\n                    }\n                }\n                return max.event;\n            }\n        }\n        return null;\n    }\n    /**\n     * Iterate over everything in the timeline.\n     * @param  callback The callback to invoke with every item\n     */\n    forEach(callback) {\n        if (this._root !== null) {\n            const allNodes = [];\n            this._root.traverse(node => allNodes.push(node));\n            allNodes.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the given time\n     * overlaps with the time and duration time of the event.\n     * @param  time The time to check if items are overlapping\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAtTime(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            results.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the time is greater\n     * than or equal to the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachFrom(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.searchAfter(time, results);\n            results.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        if (this._root !== null) {\n            this._root.traverse(node => node.dispose());\n        }\n        this._root = null;\n        return this;\n    }\n}\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n    constructor(low, high, event) {\n        // the nodes to the left\n        this._left = null;\n        // the nodes to the right\n        this._right = null;\n        // the parent node\n        this.parent = null;\n        // the number of child nodes\n        this.height = 0;\n        this.event = event;\n        // the low value\n        this.low = low;\n        // the high value\n        this.high = high;\n        // the high value for this and all child nodes\n        this.max = this.high;\n    }\n    /**\n     * Insert a node into the correct spot in the tree\n     */\n    insert(node) {\n        if (node.low <= this.low) {\n            if (this.left === null) {\n                this.left = node;\n            }\n            else {\n                this.left.insert(node);\n            }\n        }\n        else if (this.right === null) {\n            this.right = node;\n        }\n        else {\n            this.right.insert(node);\n        }\n    }\n    /**\n     * Search the tree for nodes which overlap\n     * with the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    search(point, results) {\n        // If p is to the right of the rightmost point of any interval\n        // in this node and all children, there won't be any matches.\n        if (point > this.max) {\n            return;\n        }\n        // Search left children\n        if (this.left !== null) {\n            this.left.search(point, results);\n        }\n        // Check this node\n        if (this.low <= point && this.high > point) {\n            results.push(this);\n        }\n        // If p is to the left of the time of this interval,\n        // then it can't be in any child to the right.\n        if (this.low > point) {\n            return;\n        }\n        // Search right children\n        if (this.right !== null) {\n            this.right.search(point, results);\n        }\n    }\n    /**\n     * Search the tree for nodes which are less\n     * than the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    searchAfter(point, results) {\n        // Check this node\n        if (this.low >= point) {\n            results.push(this);\n            if (this.left !== null) {\n                this.left.searchAfter(point, results);\n            }\n        }\n        // search the right side\n        if (this.right !== null) {\n            this.right.searchAfter(point, results);\n        }\n    }\n    /**\n     * Invoke the callback on this element and both it's branches\n     * @param  {Function}  callback\n     */\n    traverse(callback) {\n        callback(this);\n        if (this.left !== null) {\n            this.left.traverse(callback);\n        }\n        if (this.right !== null) {\n            this.right.traverse(callback);\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateHeight() {\n        if (this.left !== null && this.right !== null) {\n            this.height = Math.max(this.left.height, this.right.height) + 1;\n        }\n        else if (this.right !== null) {\n            this.height = this.right.height + 1;\n        }\n        else if (this.left !== null) {\n            this.height = this.left.height + 1;\n        }\n        else {\n            this.height = 0;\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateMax() {\n        this.max = this.high;\n        if (this.left !== null) {\n            this.max = Math.max(this.max, this.left.max);\n        }\n        if (this.right !== null) {\n            this.max = Math.max(this.max, this.right.max);\n        }\n    }\n    /**\n     * The balance is how the leafs are distributed on the node\n     * @return  Negative numbers are balanced to the right\n     */\n    getBalance() {\n        let balance = 0;\n        if (this.left !== null && this.right !== null) {\n            balance = this.left.height - this.right.height;\n        }\n        else if (this.left !== null) {\n            balance = this.left.height + 1;\n        }\n        else if (this.right !== null) {\n            balance = -(this.right.height + 1);\n        }\n        return balance;\n    }\n    /**\n     * @returns true if this node is the left child of its parent\n     */\n    isLeftChild() {\n        return this.parent !== null && this.parent.left === this;\n    }\n    /**\n     * get/set the left node\n     */\n    get left() {\n        return this._left;\n    }\n    set left(node) {\n        this._left = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * get/set the right node\n     */\n    get right() {\n        return this._right;\n    }\n    set right(node) {\n        this._right = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * null out references.\n     */\n    dispose() {\n        this.parent = null;\n        this._left = null;\n        this._right = null;\n        this.event = null;\n    }\n}\n//# sourceMappingURL=IntervalTimeline.js.map","import { noOp } from \"../util/Interface\";\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n    /**\n     * @param transport The transport object which the event belongs to\n     */\n    constructor(transport, opts) {\n        /**\n         * The unique id of the event\n         */\n        this.id = TransportEvent._eventId++;\n        const options = Object.assign(TransportEvent.getDefaults(), opts);\n        this.transport = transport;\n        this.callback = options.callback;\n        this._once = options.once;\n        this.time = options.time;\n    }\n    static getDefaults() {\n        return {\n            callback: noOp,\n            once: false,\n            time: 0,\n        };\n    }\n    /**\n     * Invoke the event callback.\n     * @param  time  The AudioContext time in seconds of the event\n     */\n    invoke(time) {\n        if (this.callback) {\n            this.callback(time);\n            if (this._once) {\n                this.transport.clear(this.id);\n            }\n        }\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this.callback = undefined;\n        return this;\n    }\n}\n/**\n * Current ID counter\n */\nTransportEvent._eventId = 0;\n//# sourceMappingURL=TransportEvent.js.map","import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n    /**\n     * @param transport The transport object which the event belongs to\n     */\n    constructor(transport, opts) {\n        super(transport, opts);\n        /**\n         * The ID of the current timeline event\n         */\n        this._currentId = -1;\n        /**\n         * The ID of the next timeline event\n         */\n        this._nextId = -1;\n        /**\n         * The time of the next event\n         */\n        this._nextTick = this.time;\n        /**\n         * a reference to the bound start method\n         */\n        this._boundRestart = this._restart.bind(this);\n        const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n        this.duration = new TicksClass(transport.context, options.duration).valueOf();\n        this._interval = new TicksClass(transport.context, options.interval).valueOf();\n        this._nextTick = options.time;\n        this.transport.on(\"start\", this._boundRestart);\n        this.transport.on(\"loopStart\", this._boundRestart);\n        this.context = this.transport.context;\n        this._restart();\n    }\n    static getDefaults() {\n        return Object.assign({}, TransportEvent.getDefaults(), {\n            duration: Infinity,\n            interval: 1,\n            once: false,\n        });\n    }\n    /**\n     * Invoke the callback. Returns the tick time which\n     * the next event should be scheduled at.\n     * @param  time  The AudioContext time in seconds of the event\n     */\n    invoke(time) {\n        // create more events if necessary\n        this._createEvents(time);\n        // call the super class\n        super.invoke(time);\n    }\n    /**\n     * Push more events onto the timeline to keep up with the position of the timeline\n     */\n    _createEvents(time) {\n        // schedule the next event\n        const ticks = this.transport.getTicksAtTime(time);\n        if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n            this._nextTick += this._interval;\n            this._currentId = this._nextId;\n            this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        }\n    }\n    /**\n     * Push more events onto the timeline to keep up with the position of the timeline\n     */\n    _restart(time) {\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        this._nextTick = this.time;\n        const ticks = this.transport.getTicksAtTime(time);\n        if (ticks > this.time) {\n            this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n        }\n        this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        this._nextTick += this._interval;\n        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        this.transport.off(\"start\", this._boundRestart);\n        this.transport.off(\"loopStart\", this._boundRestart);\n        return this;\n    }\n}\n//# sourceMappingURL=TransportRepeatEvent.js.map","import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Transport.getDefaults(), arguments));\n        this.name = \"Transport\";\n        //-------------------------------------\n        // \tLOOPING\n        //-------------------------------------\n        /**\n         * If the transport loops or not.\n         */\n        this._loop = new TimelineValue(false);\n        /**\n         * The loop start position in ticks\n         */\n        this._loopStart = 0;\n        /**\n         * The loop end position in ticks\n         */\n        this._loopEnd = 0;\n        //-------------------------------------\n        // \tTIMELINE EVENTS\n        //-------------------------------------\n        /**\n         * All the events in an object to keep track by ID\n         */\n        this._scheduledEvents = {};\n        /**\n         * The scheduled events.\n         */\n        this._timeline = new Timeline();\n        /**\n         * Repeated events\n         */\n        this._repeatedEvents = new IntervalTimeline();\n        /**\n         * All of the synced Signals\n         */\n        this._syncedSignals = [];\n        /**\n         * The swing amount\n         */\n        this._swingAmount = 0;\n        const options = optionsFromArguments(Transport.getDefaults(), arguments);\n        // CLOCK/TEMPO\n        this._ppq = options.ppq;\n        this._clock = new Clock({\n            callback: this._processTick.bind(this),\n            context: this.context,\n            frequency: 0,\n            units: \"bpm\",\n        });\n        this._bindClockEvents();\n        this.bpm = this._clock.frequency;\n        this._clock.frequency.multiplier = options.ppq;\n        this.bpm.setValueAtTime(options.bpm, 0);\n        readOnly(this, \"bpm\");\n        this._timeSignature = options.timeSignature;\n        // SWING\n        this._swingTicks = options.ppq / 2; // 8n\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            bpm: 120,\n            loopEnd: \"4m\",\n            loopStart: 0,\n            ppq: 192,\n            swing: 0,\n            swingSubdivision: \"8n\",\n            timeSignature: 4,\n        });\n    }\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    _processTick(tickTime, ticks) {\n        // handle swing\n        if (this._swingAmount > 0 &&\n            ticks % this._ppq !== 0 && // not on a downbeat\n            ticks % (this._swingTicks * 2) !== 0) {\n            // add some swing\n            const progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n            const amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n            tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n        }\n        // do the loop test\n        if (this._loop.get(tickTime)) {\n            if (ticks >= this._loopEnd) {\n                this.emit(\"loopEnd\", tickTime);\n                this._clock.setTicksAtTime(this._loopStart, tickTime);\n                ticks = this._loopStart;\n                this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n                this.emit(\"loop\", tickTime);\n            }\n        }\n        // invoke the timeline events scheduled on this tick\n        this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n    }\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n    schedule(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n    scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n        const event = new TransportRepeatEvent(this, {\n            callback,\n            duration: new TimeClass(this.context, duration).toTicks(),\n            interval: new TimeClass(this.context, interval).toTicks(),\n            time: new TransportTimeClass(this.context, startTime).toTicks(),\n        });\n        // kick it off if the Transport is started\n        // @ts-ignore\n        return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n    scheduleOnce(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            once: true,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n    clear(eventId) {\n        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n            const item = this._scheduledEvents[eventId.toString()];\n            item.timeline.remove(item.event);\n            item.event.dispose();\n            delete this._scheduledEvents[eventId.toString()];\n        }\n        return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n    _addEvent(event, timeline) {\n        this._scheduledEvents[event.id.toString()] = {\n            event,\n            timeline,\n        };\n        timeline.add(event);\n        return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n    cancel(after = 0) {\n        const computedAfter = this.toTicks(after);\n        this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n        this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n        return this;\n    }\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n    _bindClockEvents() {\n        this._clock.on(\"start\", (time, offset) => {\n            offset = new TicksClass(this.context, offset).toSeconds();\n            this.emit(\"start\", time, offset);\n        });\n        this._clock.on(\"stop\", (time) => {\n            this.emit(\"stop\", time);\n        });\n        this._clock.on(\"pause\", (time) => {\n            this.emit(\"pause\", time);\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n    get state() {\n        return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n    start(time, offset) {\n        let offsetTicks;\n        if (isDefined(offset)) {\n            offsetTicks = this.toTicks(offset);\n        }\n        // start the clock\n        this._clock.start(time, offsetTicks);\n        return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n    stop(time) {\n        this._clock.stop(time);\n        return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n    pause(time) {\n        this._clock.pause(time);\n        return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n    toggle(time) {\n        time = this.toSeconds(time);\n        if (this._clock.getStateAtTime(time) !== \"started\") {\n            this.start(time);\n        }\n        else {\n            this.stop(time);\n        }\n        return this;\n    }\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n    get timeSignature() {\n        return this._timeSignature;\n    }\n    set timeSignature(timeSig) {\n        if (isArray(timeSig)) {\n            timeSig = (timeSig[0] / timeSig[1]) * 4;\n        }\n        this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n    get loopStart() {\n        return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    }\n    set loopStart(startPosition) {\n        this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n    get loopEnd() {\n        return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    }\n    set loopEnd(endPosition) {\n        this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n    get loop() {\n        return this._loop.get(this.now());\n    }\n    set loop(loop) {\n        this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n    setLoopPoints(startPosition, endPosition) {\n        this.loopStart = startPosition;\n        this.loopEnd = endPosition;\n        return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n    get swing() {\n        return this._swingAmount;\n    }\n    set swing(amount) {\n        // scale the values to a normal range\n        this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n    get swingSubdivision() {\n        return new TicksClass(this.context, this._swingTicks).toNotation();\n    }\n    set swingSubdivision(subdivision) {\n        this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n    get position() {\n        const now = this.now();\n        const ticks = this._clock.getTicksAtTime(now);\n        return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    }\n    set position(progress) {\n        const ticks = this.toTicks(progress);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n    get seconds() {\n        return this._clock.seconds;\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this._clock.frequency.timeToTicks(s, now);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n    get progress() {\n        if (this.loop) {\n            const now = this.now();\n            const ticks = this._clock.getTicksAtTime(now);\n            return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The transports current tick position.\n     */\n    get ticks() {\n        return this._clock.ticks;\n    }\n    set ticks(t) {\n        if (this._clock.ticks !== t) {\n            const now = this.now();\n            // stop everything synced to the transport\n            if (this.state === \"started\") {\n                const ticks = this._clock.getTicksAtTime(now);\n                // schedule to start on the next tick, #573\n                const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n                this.emit(\"stop\", time);\n                this._clock.setTicksAtTime(t, time);\n                // restart it with the new time\n                this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n            }\n            else {\n                this._clock.setTicksAtTime(t, now);\n            }\n        }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n    get PPQ() {\n        return this._clock.frequency.multiplier;\n    }\n    set PPQ(ppq) {\n        this._clock.frequency.multiplier = ppq;\n    }\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n    nextSubdivision(subdivision) {\n        subdivision = this.toTicks(subdivision);\n        if (this.state !== \"started\") {\n            // if the transport's not started, return 0\n            return 0;\n        }\n        else {\n            const now = this.now();\n            // the remainder of the current ticks and the subdivision\n            const transportPos = this.getTicksAtTime(now);\n            const remainingTicks = subdivision - transportPos % subdivision;\n            return this._clock.nextTickTime(remainingTicks, now);\n        }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n    syncSignal(signal, ratio) {\n        if (!ratio) {\n            // get the sync ratio\n            const now = this.now();\n            if (signal.getValueAtTime(now) !== 0) {\n                const bpm = this.bpm.getValueAtTime(now);\n                const computedFreq = 1 / (60 / bpm / this.PPQ);\n                ratio = signal.getValueAtTime(now) / computedFreq;\n            }\n            else {\n                ratio = 0;\n            }\n        }\n        const ratioSignal = new Gain(ratio);\n        // @ts-ignore\n        this.bpm.connect(ratioSignal);\n        // @ts-ignore\n        ratioSignal.connect(signal._param);\n        this._syncedSignals.push({\n            initial: signal.value,\n            ratio: ratioSignal,\n            signal,\n        });\n        signal.value = 0;\n        return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n    unsyncSignal(signal) {\n        for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n            const syncedSignal = this._syncedSignals[i];\n            if (syncedSignal.signal === signal) {\n                syncedSignal.ratio.dispose();\n                syncedSignal.signal.value = syncedSignal.initial;\n                this._syncedSignals.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._clock.dispose();\n        writable(this, \"bpm\");\n        this._timeline.dispose();\n        this._repeatedEvents.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Transport);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.transport = new Transport({ context });\n});\nonContextClose(context => {\n    context.transport.dispose();\n});\n//# sourceMappingURL=Transport.js.map","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n        this.name = \"Volume\";\n        const options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n        this.input = this.output = new Gain({\n            context: this.context,\n            gain: options.volume,\n            units: \"decibels\",\n        });\n        this.volume = this.output.gain;\n        readOnly(this, \"volume\");\n        this._unmutedVolume = options.volume;\n        // set the mute initially\n        this.mute = options.mute;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0,\n        });\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const vol = new Tone.Volume(-12).toDestination();\n     * const osc = new Tone.Oscillator().connect(vol).start();\n     * // mute the output\n     * vol.mute = true;\n     */\n    get mute() {\n        return this.volume.value === -Infinity;\n    }\n    set mute(mute) {\n        if (!this.mute && mute) {\n            this._unmutedVolume = this.volume.value;\n            // maybe it should ramp here?\n            this.volume.value = -Infinity;\n        }\n        else if (this.mute && !mute) {\n            this.volume.value = this._unmutedVolume;\n        }\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this.input.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Volume.js.map","import { Volume } from \"../../component/channel/Volume\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { connectSeries, ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class Destination extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Destination.getDefaults(), arguments));\n        this.name = \"Destination\";\n        this.input = new Volume({ context: this.context });\n        this.output = new Gain({ context: this.context });\n        /**\n         * The volume of the master output.\n         */\n        this.volume = this.input.volume;\n        const options = optionsFromArguments(Destination.getDefaults(), arguments);\n        connectSeries(this.input, this.output, this.context.rawContext.destination);\n        this.mute = options.mute;\n        this._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0,\n        });\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const oscillator = new Tone.Oscillator().start().toDestination();\n     * setTimeout(() => {\n     * \t// mute the output\n     * \tTone.Destination.mute = true;\n     * }, 1000);\n     */\n    get mute() {\n        return this.input.mute;\n    }\n    set mute(mute) {\n        this.input.mute = mute;\n    }\n    /**\n     * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n     * chained in the master effects chain.\n     * @param args All arguments will be connected in a row and the Master will be routed through it.\n     * @example\n     * // route all audio through a filter and compressor\n     * const lowpass = new Tone.Filter(800, \"lowpass\");\n     * const compressor = new Tone.Compressor(-18);\n     * Tone.Destination.chain(lowpass, compressor);\n     */\n    chain(...args) {\n        this.input.disconnect();\n        args.unshift(this.input);\n        args.push(this.output);\n        connectSeries(...args);\n        return this;\n    }\n    /**\n     * The maximum number of channels the system can output\n     * @example\n     * console.log(Tone.Destination.maxChannelCount);\n     */\n    get maxChannelCount() {\n        return this.context.rawContext.destination.maxChannelCount;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.destination = new Destination({ context });\n});\nonContextClose(context => {\n    context.destination.dispose();\n});\n//# sourceMappingURL=Destination.js.map","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\nimport { assert } from \"../util/Debug\";\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tC1: \"https://tonejs.github.io/examples/audio/casio/C1.mp3\",\n * \tC2: \"https://tonejs.github.io/examples/audio/casio/C2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t C1: \"C1.mp3\",\n * \t\t C2: \"C2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/examples/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n    constructor() {\n        super();\n        this.name = \"ToneAudioBuffers\";\n        /**\n         * All of the buffers\n         */\n        this._buffers = new Map();\n        /**\n         * Keep track of the number of loaded buffers\n         */\n        this._loadingCount = 0;\n        const options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        this.baseUrl = options.baseUrl;\n        // add each one\n        Object.keys(options.urls).forEach(name => {\n            this._loadingCount++;\n            const url = options.urls[name];\n            this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n        });\n    }\n    static getDefaults() {\n        return {\n            baseUrl: \"\",\n            onerror: noOp,\n            onload: noOp,\n            urls: {},\n        };\n    }\n    /**\n     * True if the buffers object has a buffer by that name.\n     * @param  name  The key or index of the buffer.\n     */\n    has(name) {\n        return this._buffers.has(name.toString());\n    }\n    /**\n     * Get a buffer by name. If an array was loaded,\n     * then use the array index.\n     * @param  name  The key or index of the buffer.\n     */\n    get(name) {\n        assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n        return this._buffers.get(name.toString());\n    }\n    /**\n     * A buffer was loaded. decrement the counter.\n     */\n    _bufferLoaded(callback) {\n        this._loadingCount--;\n        if (this._loadingCount === 0 && callback) {\n            callback();\n        }\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n    get loaded() {\n        return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n    }\n    /**\n     * Add a buffer by name and url to the Buffers\n     * @param  name      A unique name to give the buffer\n     * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     * @param  onerror  Invoked if the buffer can't be loaded\n     */\n    add(name, url, callback = noOp, onerror = noOp) {\n        if (isString(url)) {\n            this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n        }\n        else {\n            this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n        }\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._buffers.forEach(buffer => buffer.dispose());\n        this._buffers.clear();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneAudioBuffers.js.map","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { Timeline } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class Draw extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        this.name = \"Draw\";\n        /**\n         * The duration after which events are not invoked.\n         */\n        this.expiration = 0.25;\n        /**\n         * The amount of time before the scheduled time\n         * that the callback can be invoked. Default is\n         * half the time of an animation frame (0.008 seconds).\n         */\n        this.anticipation = 0.008;\n        /**\n         * All of the events.\n         */\n        this._events = new Timeline();\n        /**\n         * The draw loop\n         */\n        this._boundDrawLoop = this._drawLoop.bind(this);\n        /**\n         * The animation frame id\n         */\n        this._animationFrame = -1;\n    }\n    /**\n     * Schedule a function at the given time to be invoked\n     * on the nearest animation frame.\n     * @param  callback  Callback is invoked at the given time.\n     * @param  time      The time relative to the AudioContext time to invoke the callback.\n     * @example\n     * Tone.Transport.scheduleRepeat(time => {\n     * \tTone.Draw.schedule(() => console.log(time), time);\n     * }, 1);\n     * Tone.Transport.start();\n     */\n    schedule(callback, time) {\n        this._events.add({\n            callback,\n            time: this.toSeconds(time),\n        });\n        // start the draw loop on the first event\n        if (this._events.length === 1) {\n            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n        }\n        return this;\n    }\n    /**\n     * Cancel events scheduled after the given time\n     * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n     */\n    cancel(after) {\n        this._events.cancel(this.toSeconds(after));\n        return this;\n    }\n    /**\n     * The draw loop\n     */\n    _drawLoop() {\n        const now = this.context.currentTime;\n        while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n            const event = this._events.shift();\n            if (event && now - event.time <= this.expiration) {\n                event.callback();\n            }\n        }\n        if (this._events.length > 0) {\n            this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        cancelAnimationFrame(this._animationFrame);\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.draw = new Draw({ context });\n});\nonContextClose(context => {\n    context.draw.dispose();\n});\n//# sourceMappingURL=Draw.js.map","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * Sources have no inputs\n         */\n        this.input = undefined;\n        /**\n         * Keep track of the scheduled state.\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * The synced `start` callback function from the transport\n         */\n        this._synced = false;\n        /**\n         * Keep track of all of the scheduled event ids\n         */\n        this._scheduled = [];\n        /**\n         * Placeholder functions for syncing/unsyncing to transport\n         */\n        this._syncedStart = noOp;\n        this._syncedStop = noOp;\n        this._state.memory = 100;\n        this._state.increasing = true;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            mute: options.mute,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.onstop = options.onstop;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            onstop: noOp,\n            volume: 0,\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get state() {\n        if (this._synced) {\n            if (this.context.transport.state === \"started\") {\n                return this._state.getValueAtTime(this.context.transport.seconds);\n            }\n            else {\n                return \"stopped\";\n            }\n        }\n        else {\n            return this._state.getValueAtTime(this.now());\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    _clampToCurrentTime(time) {\n        if (this._synced) {\n            return time;\n        }\n        else {\n            return Math.max(time, this.context.currentTime);\n        }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n    start(time, offset, duration) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        // if it's started, stop it and restart it\n        if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n            // time should be strictly greater than the previous start time\n            assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            this.log(\"restart\", computedTime);\n            this.restart(computedTime, offset, duration);\n        }\n        else {\n            this.log(\"start\", computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (this._synced) {\n                // add the offset time to the event\n                const event = this._state.get(computedTime);\n                if (event) {\n                    event.offset = this.toSeconds(defaultArg(offset, 0));\n                    event.duration = duration ? this.toSeconds(duration) : undefined;\n                }\n                const sched = this.context.transport.schedule(t => {\n                    this._start(t, offset, duration);\n                }, computedTime);\n                this._scheduled.push(sched);\n                // if the transport is already started\n                // and the time is greater than where the transport is\n                if (this.context.transport.state === \"started\" &&\n                    this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n                    this._syncedStart(this.now(), this.context.transport.seconds);\n                }\n            }\n            else {\n                assertContextRunning(this.context);\n                this._start(computedTime, offset, duration);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n    stop(time) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n            this.log(\"stop\", computedTime);\n            if (!this._synced) {\n                this._stop(computedTime);\n            }\n            else {\n                const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n                this._scheduled.push(sched);\n            }\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"stopped\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Restart the source.\n     */\n    restart(time, offset, duration) {\n        time = this.toSeconds(time);\n        if (this._state.getValueAtTime(time) === \"started\") {\n            this._state.cancel(time);\n            this._restart(time, offset, duration);\n        }\n        return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n    sync() {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncedStart = (time, offset) => {\n                if (offset > 0) {\n                    // get the playback state at that time\n                    const stateEvent = this._state.get(offset);\n                    // listen for start events which may occur in the middle of the sync'ed time\n                    if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n                        // get the offset\n                        const startOffset = offset - this.toSeconds(stateEvent.time);\n                        let duration;\n                        if (stateEvent.duration) {\n                            duration = this.toSeconds(stateEvent.duration) - startOffset;\n                        }\n                        this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n                    }\n                }\n            };\n            this._syncedStop = time => {\n                const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n                if (this._state.getValueAtTime(seconds) === \"started\") {\n                    this._stop(time);\n                }\n            };\n            this.context.transport.on(\"start\", this._syncedStart);\n            this.context.transport.on(\"loopStart\", this._syncedStart);\n            this.context.transport.on(\"stop\", this._syncedStop);\n            this.context.transport.on(\"pause\", this._syncedStop);\n            this.context.transport.on(\"loopEnd\", this._syncedStop);\n        }\n        return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n    unsync() {\n        if (this._synced) {\n            this.context.transport.off(\"stop\", this._syncedStop);\n            this.context.transport.off(\"pause\", this._syncedStop);\n            this.context.transport.off(\"loopEnd\", this._syncedStop);\n            this.context.transport.off(\"start\", this._syncedStart);\n            this.context.transport.off(\"loopStart\", this._syncedStart);\n        }\n        this._synced = false;\n        // clear all of the scheduled ids\n        this._scheduled.forEach(id => this.context.transport.clear(id));\n        this._scheduled = [];\n        this._state.cancel(0);\n        // stop it also\n        this._stop(0);\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.onstop = noOp;\n        this.unsync();\n        this._volume.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Source.js.map","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource {\n    constructor() {\n        super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n        this.name = \"ToneBufferSource\";\n        /**\n         * The oscillator\n         */\n        this._source = this.context.createBufferSource();\n        this._internalChannels = [this._source];\n        /**\n         * indicators if the source has started/stopped\n         */\n        this._sourceStarted = false;\n        this._sourceStopped = false;\n        const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n        connect(this._source, this._gainNode);\n        this._source.onended = () => this._stopSource();\n        /**\n         * The playbackRate of the buffer\n         */\n        this.playbackRate = new Param({\n            context: this.context,\n            param: this._source.playbackRate,\n            units: \"positive\",\n            value: options.playbackRate,\n        });\n        // set some values initially\n        this.loop = options.loop;\n        this.loopStart = options.loopStart;\n        this.loopEnd = options.loopEnd;\n        this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n        this._internalChannels.push(this._source);\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            url: new ToneAudioBuffer(),\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            onload: noOp,\n            onerror: noOp,\n            playbackRate: 1,\n        });\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get fadeIn() {\n        return this._fadeIn;\n    }\n    set fadeIn(t) {\n        this._fadeIn = t;\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get fadeOut() {\n        return this._fadeOut;\n    }\n    set fadeOut(t) {\n        this._fadeOut = t;\n    }\n    /**\n     * The curve applied to the fades, either \"linear\" or \"exponential\"\n     */\n    get curve() {\n        return this._curve;\n    }\n    set curve(t) {\n        this._curve = t;\n    }\n    /**\n     * Start the buffer\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     * @param  gain  The gain to play the buffer back at.\n     */\n    start(time, offset, duration, gain = 1) {\n        assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n        const computedTime = this.toSeconds(time);\n        // apply the gain envelope\n        this._startGain(computedTime, gain);\n        // if it's a loop the default offset is the loopstart point\n        if (this.loop) {\n            offset = defaultArg(offset, this.loopStart);\n        }\n        else {\n            // otherwise the default offset is 0\n            offset = defaultArg(offset, 0);\n        }\n        // make sure the offset is not less than 0\n        let computedOffset = Math.max(this.toSeconds(offset), 0);\n        // start the buffer source\n        if (this.loop) {\n            // modify the offset if it's greater than the loop time\n            const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n            const loopStart = this.toSeconds(this.loopStart);\n            const loopDuration = loopEnd - loopStart;\n            // move the offset back\n            if (GTE(computedOffset, loopEnd)) {\n                computedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n            }\n            // when the offset is very close to the duration, set it to 0\n            if (EQ(computedOffset, this.buffer.duration)) {\n                computedOffset = 0;\n            }\n        }\n        // this.buffer.loaded would have return false if the AudioBuffer was undefined\n        this._source.buffer = this.buffer.get();\n        this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n        if (LT(computedOffset, this.buffer.duration)) {\n            this._sourceStarted = true;\n            this._source.start(computedTime, computedOffset);\n        }\n        // if a duration is given, schedule a stop\n        if (isDefined(duration)) {\n            let computedDur = this.toSeconds(duration);\n            // make sure it's never negative\n            computedDur = Math.max(computedDur, 0);\n            this.stop(computedTime + computedDur);\n        }\n        return this;\n    }\n    _stopSource(time) {\n        if (!this._sourceStopped && this._sourceStarted) {\n            this._sourceStopped = true;\n            this._source.stop(this.toSeconds(time));\n            this._onended();\n        }\n    }\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n    get loopStart() {\n        return this._source.loopStart;\n    }\n    set loopStart(loopStart) {\n        this._source.loopStart = this.toSeconds(loopStart);\n    }\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n    get loopEnd() {\n        return this._source.loopEnd;\n    }\n    set loopEnd(loopEnd) {\n        this._source.loopEnd = this.toSeconds(loopEnd);\n    }\n    /**\n     * The audio buffer belonging to the player.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    set buffer(buffer) {\n        this._buffer.set(buffer);\n    }\n    /**\n     * If the buffer should loop once it's over.\n     */\n    get loop() {\n        return this._source.loop;\n    }\n    set loop(loop) {\n        this._source.loop = loop;\n        if (this._sourceStarted) {\n            this.cancelStop();\n        }\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._source.onended = null;\n        this._source.disconnect();\n        this._buffer.dispose();\n        this.playbackRate.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneBufferSource.js.map","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source {\n    constructor() {\n        super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n        this.name = \"Noise\";\n        /**\n         * Private reference to the source\n         */\n        this._source = null;\n        const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n        this._playbackRate = options.playbackRate;\n        this.type = options.type;\n        this._fadeIn = options.fadeIn;\n        this._fadeOut = options.fadeOut;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            fadeIn: 0,\n            fadeOut: 0,\n            playbackRate: 1,\n            type: \"white\",\n        });\n    }\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n        if (this._type !== type) {\n            this._type = type;\n            // if it's playing, stop and restart it\n            if (this.state === \"started\") {\n                const now = this.now();\n                this._stop(now);\n                this._start(now);\n            }\n        }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        if (this._source) {\n            this._source.playbackRate.value = rate;\n        }\n    }\n    /**\n     * internal start method\n     */\n    _start(time) {\n        const buffer = _noiseBuffers[this._type];\n        this._source = new ToneBufferSource({\n            url: buffer,\n            context: this.context,\n            fadeIn: this._fadeIn,\n            fadeOut: this._fadeOut,\n            loop: true,\n            onended: () => this.onstop(this),\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n    _stop(time) {\n        if (this._source) {\n            this._source.stop(this.toSeconds(time));\n            this._source = null;\n        }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get fadeIn() {\n        return this._fadeIn;\n    }\n    set fadeIn(time) {\n        this._fadeIn = time;\n        if (this._source) {\n            this._source.fadeIn = this._fadeIn;\n        }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get fadeOut() {\n        return this._fadeOut;\n    }\n    set fadeOut(time) {\n        this._fadeOut = time;\n        if (this._source) {\n            this._source.fadeOut = this._fadeOut;\n        }\n    }\n    _restart(time) {\n        // TODO could be optimized by cancelling the buffer source 'stop'\n        this._stop(time);\n        this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this._source) {\n            this._source.disconnect();\n        }\n        return this;\n    }\n}\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\nconst _noiseCache = {\n    brown: null,\n    pink: null,\n    white: null,\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n    get brown() {\n        if (!_noiseCache.brown) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let lastOut = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    channel[i] = (lastOut + (0.02 * white)) / 1.02;\n                    lastOut = channel[i];\n                    channel[i] *= 3.5; // (roughly) compensate for gain\n                }\n            }\n            _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.brown;\n    },\n    get pink() {\n        if (!_noiseCache.pink) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let b0, b1, b2, b3, b4, b5, b6;\n                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    b0 = 0.99886 * b0 + white * 0.0555179;\n                    b1 = 0.99332 * b1 + white * 0.0750759;\n                    b2 = 0.96900 * b2 + white * 0.1538520;\n                    b3 = 0.86650 * b3 + white * 0.3104856;\n                    b4 = 0.55000 * b4 + white * 0.5329522;\n                    b5 = -0.7616 * b5 - white * 0.0168980;\n                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n                    channel[i] *= 0.11; // (roughly) compensate for gain\n                    b6 = white * 0.115926;\n                }\n            }\n            _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.pink;\n    },\n    get white() {\n        if (!_noiseCache.white) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    channel[i] = Math.random() * 2 - 1;\n                }\n            }\n            _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.white;\n    },\n};\n//# sourceMappingURL=Noise.js.map","import { __awaiter } from \"tslib\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport function generateWaveform(instance, length) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const duration = length / instance.context.sampleRate;\n        const context = new OfflineContext(1, duration, instance.context.sampleRate);\n        const clone = new instance.constructor(Object.assign(instance.get(), {\n            // should do 2 iterations\n            frequency: 2 / duration,\n            // zero out the detune\n            detune: 0,\n            context\n        })).toDestination();\n        clone.start(0);\n        const buffer = yield context.render();\n        return buffer.getChannelData(0);\n    });\n}\n//# sourceMappingURL=OscillatorInterface.js.map","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource {\n    constructor() {\n        super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"ToneOscillatorNode\";\n        /**\n         * The oscillator\n         */\n        this._oscillator = this.context.createOscillator();\n        this._internalChannels = [this._oscillator];\n        const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        connect(this._oscillator, this._gainNode);\n        this.type = options.type;\n        this.frequency = new Param({\n            context: this.context,\n            param: this._oscillator.frequency,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Param({\n            context: this.context,\n            param: this._oscillator.detune,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            type: \"sine\",\n        });\n    }\n    /**\n     * Start the oscillator node at the given time\n     * @param  time When to start the oscillator\n     */\n    start(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        this._startGain(computedTime);\n        this._oscillator.start(computedTime);\n        return this;\n    }\n    _stopSource(time) {\n        this._oscillator.stop(time);\n    }\n    /**\n     * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n     * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n     */\n    setPeriodicWave(periodicWave) {\n        this._oscillator.setPeriodicWave(periodicWave);\n        return this;\n    }\n    /**\n     * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n     */\n    get type() {\n        return this._oscillator.type;\n    }\n    set type(type) {\n        this._oscillator.type = type;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this.state === \"started\") {\n            this.stop();\n        }\n        this._oscillator.disconnect();\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneOscillatorNode.js.map","import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"Oscillator\";\n        /**\n         * the main oscillator\n         */\n        this._oscillator = null;\n        const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, \"detune\");\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        this._type = options.type;\n        if (options.partialCount && options.type !== \"custom\") {\n            this._type = this.baseType + options.partialCount.toString();\n        }\n        this.phase = options.phase;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            partialCount: 0,\n            partials: [],\n            phase: 0,\n            type: \"sine\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        const computedTime = this.toSeconds(time);\n        // new oscillator with previous values\n        const oscillator = new ToneOscillatorNode({\n            context: this.context,\n            onended: () => this.onstop(this),\n        });\n        this._oscillator = oscillator;\n        if (this._wave) {\n            this._oscillator.setPeriodicWave(this._wave);\n        }\n        else {\n            this._oscillator.type = this._type;\n        }\n        // connect the control signal to the oscillator frequency & detune\n        this._oscillator.connect(this.output);\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        // start the oscillator\n        this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._oscillator) {\n            this._oscillator.stop(computedTime);\n        }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n    _restart(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"restart\", computedTime);\n        if (this._oscillator) {\n            this._oscillator.cancelStop();\n        }\n        this._state.cancel(computedTime);\n        return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n    syncFrequency() {\n        this.context.transport.syncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n    unsyncFrequency() {\n        this.context.transport.unsyncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n    _getCachedPeriodicWave() {\n        if (this._type === \"custom\") {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.phase === this._phase &&\n                    deepEquals(description.partials, this._partials);\n            });\n            return oscProps;\n        }\n        else {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.type === this._type &&\n                    description.phase === this._phase;\n            });\n            this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n            return oscProps;\n        }\n    }\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n        if (this._phase === 0 && isBasicType) {\n            this._wave = undefined;\n            this._partialCount = 0;\n            // just go with the basic approach\n            if (this._oscillator !== null) {\n                // already tested that it's a basic type\n                this._oscillator.type = type;\n            }\n        }\n        else {\n            // first check if the value is cached\n            const cache = this._getCachedPeriodicWave();\n            if (isDefined(cache)) {\n                const { partials, wave } = cache;\n                this._wave = wave;\n                this._partials = partials;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n            }\n            else {\n                const [real, imag] = this._getRealImaginary(type, this._phase);\n                const periodicWave = this.context.createPeriodicWave(real, imag);\n                this._wave = periodicWave;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n                // set the cache\n                Oscillator._periodicWaveCache.push({\n                    imag,\n                    partialCount: this._partialCount,\n                    partials: this._partials,\n                    phase: this._phase,\n                    real,\n                    type: this._type,\n                    wave: this._wave,\n                });\n                if (Oscillator._periodicWaveCache.length > 100) {\n                    Oscillator._periodicWaveCache.shift();\n                }\n            }\n        }\n    }\n    get baseType() {\n        return this._type.replace(this.partialCount.toString(), \"\");\n    }\n    set baseType(baseType) {\n        if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n            this.type = baseType + this.partialCount;\n        }\n        else {\n            this.type = baseType;\n        }\n    }\n    get partialCount() {\n        return this._partialCount;\n    }\n    set partialCount(p) {\n        assertRange(p, 0);\n        let type = this._type;\n        const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n        if (partial) {\n            type = partial[1];\n        }\n        if (this._type !== \"custom\") {\n            if (p === 0) {\n                this.type = type;\n            }\n            else {\n                this.type = type + p.toString();\n            }\n        }\n        else {\n            // extend or shorten the partials array\n            const fullPartials = new Float32Array(p);\n            // copy over the partials array\n            this._partials.forEach((v, i) => fullPartials[i] = v);\n            this._partials = Array.from(fullPartials);\n            this.type = this._type;\n        }\n    }\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    _getRealImaginary(type, phase) {\n        const fftSize = 4096;\n        let periodicWaveSize = fftSize / 2;\n        const real = new Float32Array(periodicWaveSize);\n        const imag = new Float32Array(periodicWaveSize);\n        let partialCount = 1;\n        if (type === \"custom\") {\n            partialCount = this._partials.length + 1;\n            this._partialCount = this._partials.length;\n            periodicWaveSize = partialCount;\n            // if the partial count is 0, don't bother doing any computation\n            if (this._partials.length === 0) {\n                return [real, imag];\n            }\n        }\n        else {\n            const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n            if (partial) {\n                partialCount = parseInt(partial[2], 10) + 1;\n                this._partialCount = parseInt(partial[2], 10);\n                type = partial[1];\n                partialCount = Math.max(partialCount, 2);\n                periodicWaveSize = partialCount;\n            }\n            else {\n                this._partialCount = 0;\n            }\n            this._partials = [];\n        }\n        for (let n = 1; n < periodicWaveSize; ++n) {\n            const piFactor = 2 / (n * Math.PI);\n            let b;\n            switch (type) {\n                case \"sine\":\n                    b = (n <= partialCount) ? 1 : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"square\":\n                    b = (n & 1) ? 2 * piFactor : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"sawtooth\":\n                    b = piFactor * ((n & 1) ? 1 : -1);\n                    this._partials[n - 1] = b;\n                    break;\n                case \"triangle\":\n                    if (n & 1) {\n                        b = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n                    }\n                    else {\n                        b = 0;\n                    }\n                    this._partials[n - 1] = b;\n                    break;\n                case \"custom\":\n                    b = this._partials[n - 1];\n                    break;\n                default:\n                    throw new TypeError(\"Oscillator: invalid type: \" + type);\n            }\n            if (b !== 0) {\n                real[n] = -b * Math.sin(phase * n);\n                imag[n] = b * Math.cos(phase * n);\n            }\n            else {\n                real[n] = 0;\n                imag[n] = 0;\n            }\n        }\n        return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n    _inverseFFT(real, imag, phase) {\n        let sum = 0;\n        const len = real.length;\n        for (let i = 0; i < len; i++) {\n            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n        }\n        return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n    getInitialValue() {\n        const [real, imag] = this._getRealImaginary(this._type, 0);\n        let maxValue = 0;\n        const twoPi = Math.PI * 2;\n        const testPositions = 32;\n        // check for peaks in 16 places\n        for (let i = 0; i < testPositions; i++) {\n            maxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n        }\n        return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n    get partials() {\n        return this._partials.slice(0, this.partialCount);\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this.type = \"custom\";\n        }\n    }\n    get phase() {\n        return this._phase * (180 / Math.PI);\n    }\n    set phase(phase) {\n        this._phase = phase * Math.PI / 180;\n        // reset the type\n        this.type = this._type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._oscillator !== null) {\n            this._oscillator.dispose();\n        }\n        this._wave = undefined;\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];\n//# sourceMappingURL=Oscillator.js.map","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport class SignalOperator extends ToneAudioNode {\n    constructor() {\n        super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n    }\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connectSignal(this, destination, outputNum, inputNum);\n        return this;\n    }\n}\n//# sourceMappingURL=SignalOperator.js.map","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator {\n    constructor() {\n        super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n        this.name = \"WaveShaper\";\n        /**\n         * the waveshaper node\n         */\n        this._shaper = this.context.createWaveShaper();\n        /**\n         * The input to the waveshaper node.\n         */\n        this.input = this._shaper;\n        /**\n         * The output from the waveshaper node\n         */\n        this.output = this._shaper;\n        const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n        if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n            this.curve = Float32Array.from(options.mapping);\n        }\n        else if (isFunction(options.mapping)) {\n            this.setMap(options.mapping, options.length);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            length: 1024,\n        });\n    }\n    /**\n     * Uses a mapping function to set the value of the curve.\n     * @param mapping The function used to define the values.\n     *                The mapping function take two arguments:\n     *                the first is the value at the current position\n     *                which goes from -1 to 1 over the number of elements\n     *                in the curve array. The second argument is the array position.\n     * @example\n     * const shaper = new Tone.WaveShaper();\n     * // map the input signal from [-1, 1] to [0, 10]\n     * shaper.setMap((val, index) => (val + 1) * 5);\n     */\n    setMap(mapping, length = 1024) {\n        const array = new Float32Array(length);\n        for (let i = 0, len = length; i < len; i++) {\n            const normalized = (i / (len - 1)) * 2 - 1;\n            array[i] = mapping(normalized, i);\n        }\n        this.curve = array;\n        return this;\n    }\n    /**\n     * The array to set as the waveshaper curve. For linear curves\n     * array length does not make much difference, but for complex curves\n     * longer arrays will provide smoother interpolation.\n     */\n    get curve() {\n        return this._shaper.curve;\n    }\n    set curve(mapping) {\n        this._shaper.curve = mapping;\n    }\n    /**\n     * Specifies what type of oversampling (if any) should be used when\n     * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n     */\n    get oversample() {\n        return this._shaper.oversample;\n    }\n    set oversample(oversampling) {\n        const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n        assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n        this._shaper.oversample = oversampling;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._shaper.disconnect();\n        return this;\n    }\n}\n//# sourceMappingURL=WaveShaper.js.map","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See [[GainToAudio]].\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator {\n    constructor() {\n        super(...arguments);\n        this.name = \"AudioToGain\";\n        /**\n         * The node which converts the audio ranges\n         */\n        this._norm = new WaveShaper({\n            context: this.context,\n            mapping: x => (x + 1) / 2,\n        });\n        /**\n         * The AudioRange input [-1, 1]\n         */\n        this.input = this._norm;\n        /**\n         * The GainRange output [0, 1]\n         */\n        this.output = this._norm;\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._norm.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AudioToGain.js.map","import { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal } from \"./Signal\";\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply extends Signal {\n    constructor() {\n        super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n        this.name = \"Multiply\";\n        /**\n         * Indicates if the value should be overridden on connection\n         */\n        this.override = false;\n        const options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n        this._mult = this.input = this.output = new Gain({\n            context: this.context,\n            minValue: options.minValue,\n            maxValue: options.maxValue,\n        });\n        this.factor = this._param = this._mult.gain;\n        this.factor.setValueAtTime(options.value, 0);\n    }\n    static getDefaults() {\n        return Object.assign(Signal.getDefaults(), {\n            value: 0,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._mult.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Multiply.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @offline 0.2 1\n * @example\n * const amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * @category Source\n */\nexport class AMOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n        this.name = \"AMOscillator\";\n        /**\n         * convert the -1,1 output to 0,1\n         */\n        this._modulationScale = new AudioToGain({ context: this.context });\n        /**\n         * the node where the modulation happens\n         */\n        this._modulationNode = new Gain({\n            context: this.context,\n        });\n        const options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n        this._carrier = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: options.type,\n        });\n        this.frequency = this._carrier.frequency,\n            this.detune = this._carrier.detune;\n        this._modulator = new Oscillator({\n            context: this.context,\n            phase: options.phase,\n            type: options.modulationType,\n        });\n        this.harmonicity = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.harmonicity,\n        });\n        // connections\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n        this._carrier.chain(this._modulationNode, this.output);\n        readOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            harmonicity: 1,\n            modulationType: \"square\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._modulator.start(time);\n        this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        this._modulator.stop(time);\n        this._carrier.stop(time);\n    }\n    _restart(time) {\n        this._modulator.restart(time);\n        this._carrier.restart(time);\n    }\n    /**\n     * The type of the carrier oscillator\n     */\n    get type() {\n        return this._carrier.type;\n    }\n    set type(type) {\n        this._carrier.type = type;\n    }\n    get baseType() {\n        return this._carrier.baseType;\n    }\n    set baseType(baseType) {\n        this._carrier.baseType = baseType;\n    }\n    get partialCount() {\n        return this._carrier.partialCount;\n    }\n    set partialCount(partialCount) {\n        this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n    get modulationType() {\n        return this._modulator.type;\n    }\n    set modulationType(type) {\n        this._modulator.type = type;\n    }\n    get phase() {\n        return this._carrier.phase;\n    }\n    set phase(phase) {\n        this._carrier.phase = phase;\n        this._modulator.phase = phase;\n    }\n    get partials() {\n        return this._carrier.partials;\n    }\n    set partials(partials) {\n        this._carrier.partials = partials;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.detune.dispose();\n        this.harmonicity.dispose();\n        this._carrier.dispose();\n        this._modulator.dispose();\n        this._modulationNode.dispose();\n        this._modulationScale.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @offline 0.1 1\n * @example\n * const fmOsc = new Tone.FMOscillator({\n * \tfrequency: 200,\n * \ttype: \"square\",\n * \tmodulationType: \"triangle\",\n * \tharmonicity: 0.2,\n * \tmodulationIndex: 3\n * }).toDestination().start();\n * @category Source\n */\nexport class FMOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n        this.name = \"FMOscillator\";\n        /**\n         * the node where the modulation happens\n         */\n        this._modulationNode = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n        this._carrier = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: 0,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: options.type,\n        });\n        this.detune = this._carrier.detune;\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this._modulator = new Oscillator({\n            context: this.context,\n            phase: options.phase,\n            type: options.modulationType,\n        });\n        this.harmonicity = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.harmonicity,\n        });\n        this.modulationIndex = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.modulationIndex,\n        });\n        // connections\n        this.frequency.connect(this._carrier.frequency);\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this.frequency.chain(this.modulationIndex, this._modulationNode);\n        this._modulator.connect(this._modulationNode.gain);\n        this._modulationNode.connect(this._carrier.frequency);\n        this._carrier.connect(this.output);\n        this.detune.connect(this._modulator.detune);\n        readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            harmonicity: 1,\n            modulationIndex: 2,\n            modulationType: \"square\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._modulator.start(time);\n        this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        this._modulator.stop(time);\n        this._carrier.stop(time);\n    }\n    _restart(time) {\n        this._modulator.restart(time);\n        this._carrier.restart(time);\n        return this;\n    }\n    get type() {\n        return this._carrier.type;\n    }\n    set type(type) {\n        this._carrier.type = type;\n    }\n    get baseType() {\n        return this._carrier.baseType;\n    }\n    set baseType(baseType) {\n        this._carrier.baseType = baseType;\n    }\n    get partialCount() {\n        return this._carrier.partialCount;\n    }\n    set partialCount(partialCount) {\n        this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n    get modulationType() {\n        return this._modulator.type;\n    }\n    set modulationType(type) {\n        this._modulator.type = type;\n    }\n    get phase() {\n        return this._carrier.phase;\n    }\n    set phase(phase) {\n        this._carrier.phase = phase;\n        this._modulator.phase = phase;\n    }\n    get partials() {\n        return this._carrier.partials;\n    }\n    set partials(partials) {\n        this._carrier.partials = partials;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.harmonicity.dispose();\n        this._carrier.dispose();\n        this._modulator.dispose();\n        this._modulationNode.dispose();\n        this.modulationIndex.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=FMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @offline 0.1 1\n * @example\n * const pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * @category Source\n */\nexport class PulseOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n        this.name = \"PulseOscillator\";\n        /**\n         * gate the width amount\n         */\n        this._widthGate = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        /**\n         * Threshold the signal to turn it into a square\n         */\n        this._thresh = new WaveShaper({\n            context: this.context,\n            mapping: val => val <= 0 ? -1 : 1,\n        });\n        const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n        this.width = new Signal({\n            context: this.context,\n            units: \"audioRange\",\n            value: options.width,\n        });\n        this._triangle = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: \"triangle\",\n        });\n        this.frequency = this._triangle.frequency;\n        this.detune = this._triangle.detune;\n        // connections\n        this._triangle.chain(this._thresh, this.output);\n        this.width.chain(this._widthGate, this._thresh);\n        readOnly(this, [\"width\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            phase: 0,\n            type: \"pulse\",\n            width: 0.2,\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._triangle.start(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._triangle.stop(time);\n        // the width is still connected to the output.\n        // that needs to be stopped also\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(0, time);\n    }\n    _restart(time) {\n        this._triangle.restart(time);\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._triangle.phase;\n    }\n    set phase(phase) {\n        this._triangle.phase = phase;\n    }\n    /**\n     * The type of the oscillator. Always returns \"pulse\".\n     */\n    get type() {\n        return \"pulse\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pulse\".\n     */\n    get baseType() {\n        return \"pulse\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * *Internal use* The carrier oscillator type is fed through the\n     * waveshaper node to create the pulse. Using different carrier oscillators\n     * changes oscillator's behavior.\n     */\n    set carrierType(type) {\n        this._triangle.type = type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up method.\n     */\n    dispose() {\n        super.dispose();\n        this._triangle.dispose();\n        this.width.dispose();\n        this._widthGate.dispose();\n        this._thresh.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PulseOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n        this.name = \"FatOscillator\";\n        /**\n         * The array of oscillators\n         */\n        this._oscillators = [];\n        const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        this._spread = options.spread;\n        this._type = options.type;\n        this._phase = options.phase;\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        // set the count initially\n        this.count = options.count;\n        readOnly(this, [\"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            count: 3,\n            spread: 20,\n            type: \"sawtooth\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._forEach(osc => osc.start(time));\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._forEach(osc => osc.stop(time));\n    }\n    _restart(time) {\n        this._forEach(osc => osc.restart(time));\n    }\n    /**\n     * Iterate over all of the oscillators\n     */\n    _forEach(iterator) {\n        for (let i = 0; i < this._oscillators.length; i++) {\n            iterator(this._oscillators[i], i);\n        }\n    }\n    /**\n     * The type of the oscillator\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        this._forEach(osc => osc.type = type);\n    }\n    /**\n     * The detune spread between the oscillators. If \"count\" is\n     * set to 3 oscillators and the \"spread\" is set to 40,\n     * the three oscillators would be detuned like this: [-20, 0, 20]\n     * for a total detune spread of 40 cents.\n     * @example\n     * const fatOsc = new Tone.FatOscillator().toDestination().start();\n     * fatOsc.spread = 70;\n     */\n    get spread() {\n        return this._spread;\n    }\n    set spread(spread) {\n        this._spread = spread;\n        if (this._oscillators.length > 1) {\n            const start = -spread / 2;\n            const step = spread / (this._oscillators.length - 1);\n            this._forEach((osc, i) => osc.detune.value = start + step * i);\n        }\n    }\n    /**\n     * The number of detuned oscillators. Must be an integer greater than 1.\n     * @example\n     * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n     * // use 4 sawtooth oscillators\n     * fatOsc.count = 4;\n     */\n    get count() {\n        return this._oscillators.length;\n    }\n    set count(count) {\n        assertRange(count, 1);\n        if (this._oscillators.length !== count) {\n            // dispose the previous oscillators\n            this._forEach(osc => osc.dispose());\n            this._oscillators = [];\n            for (let i = 0; i < count; i++) {\n                const osc = new Oscillator({\n                    context: this.context,\n                    volume: -6 - count * 1.1,\n                    type: this._type,\n                    phase: this._phase + (i / count) * 360,\n                    partialCount: this._partialCount,\n                    onstop: i === 0 ? () => this.onstop(this) : noOp,\n                });\n                if (this.type === \"custom\") {\n                    osc.partials = this._partials;\n                }\n                this.frequency.connect(osc.frequency);\n                this.detune.connect(osc.detune);\n                osc.detune.overridden = false;\n                osc.connect(this.output);\n                this._oscillators[i] = osc;\n            }\n            // set the spread\n            this.spread = this._spread;\n            if (this.state === \"started\") {\n                this._forEach(osc => osc.start());\n            }\n        }\n    }\n    get phase() {\n        return this._phase;\n    }\n    set phase(phase) {\n        this._phase = phase;\n        this._forEach(osc => osc.phase = phase);\n    }\n    get baseType() {\n        return this._oscillators[0].baseType;\n    }\n    set baseType(baseType) {\n        this._forEach(osc => osc.baseType = baseType);\n        this._type = this._oscillators[0].type;\n    }\n    get partials() {\n        return this._oscillators[0].partials;\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this._type = \"custom\";\n            this._forEach(osc => osc.partials = partials);\n        }\n    }\n    get partialCount() {\n        return this._oscillators[0].partialCount;\n    }\n    set partialCount(partialCount) {\n        this._partialCount = partialCount;\n        this._forEach(osc => osc.partialCount = partialCount);\n        this._type = this._oscillators[0].type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.detune.dispose();\n        this._forEach(osc => osc.dispose());\n        return this;\n    }\n}\n//# sourceMappingURL=FatOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @offline 0.1 1\n * @example\n * const pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * @category Source\n */\nexport class PWMOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n        this.name = \"PWMOscillator\";\n        this.sourceType = \"pwm\";\n        /**\n         * Scale the oscillator so it doesn't go silent\n         * at the extreme values.\n         */\n        this._scale = new Multiply({\n            context: this.context,\n            value: 2,\n        });\n        const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n        this._pulse = new PulseOscillator({\n            context: this.context,\n            frequency: options.modulationFrequency,\n        });\n        // change the pulse oscillator type\n        this._pulse.carrierType = \"sine\";\n        this.modulationFrequency = this._pulse.frequency;\n        this._modulator = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n        });\n        this.frequency = this._modulator.frequency;\n        this.detune = this._modulator.detune;\n        // connections\n        this._modulator.chain(this._scale, this._pulse.width);\n        this._pulse.connect(this.output);\n        readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            modulationFrequency: 0.4,\n            phase: 0,\n            type: \"pwm\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._modulator.start(time);\n        this._pulse.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._modulator.stop(time);\n        this._pulse.stop(time);\n    }\n    /**\n     * restart the oscillator\n     */\n    _restart(time) {\n        this._modulator.restart(time);\n        this._pulse.restart(time);\n    }\n    /**\n     * The type of the oscillator. Always returns \"pwm\".\n     */\n    get type() {\n        return \"pwm\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pwm\".\n     */\n    get baseType() {\n        return \"pwm\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._modulator.phase;\n    }\n    set phase(phase) {\n        this._modulator.phase = phase;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._pulse.dispose();\n        this._scale.dispose();\n        this._modulator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PWMOscillator.js.map","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n    am: AMOscillator,\n    fat: FatOscillator,\n    fm: FMOscillator,\n    oscillator: Oscillator,\n    pulse: PulseOscillator,\n    pwm: PWMOscillator,\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @offline 0.1 1\n * @example\n * const omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * @category Source\n */\nexport class OmniOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"OmniOscillator\";\n        const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n        // set the options\n        this.set(options);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n    _stop(time) {\n        this._oscillator.stop(time);\n    }\n    _restart(time) {\n        this._oscillator.restart(time);\n        return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n    get type() {\n        let prefix = \"\";\n        if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n            prefix = this._sourceType;\n        }\n        return prefix + this._oscillator.type;\n    }\n    set type(type) {\n        if (type.substr(0, 2) === \"fm\") {\n            this._createNewOscillator(\"fm\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 2) === \"am\") {\n            this._createNewOscillator(\"am\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 3) === \"fat\") {\n            this._createNewOscillator(\"fat\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(3);\n        }\n        else if (type === \"pwm\") {\n            this._createNewOscillator(\"pwm\");\n            this._oscillator = this._oscillator;\n        }\n        else if (type === \"pulse\") {\n            this._createNewOscillator(\"pulse\");\n        }\n        else {\n            this._createNewOscillator(\"oscillator\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type;\n        }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * See [[Oscillator.partials]]\n     */\n    get partials() {\n        return this._oscillator.partials;\n    }\n    set partials(partials) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partials = partials;\n        }\n    }\n    get partialCount() {\n        return this._oscillator.partialCount;\n    }\n    set partialCount(partialCount) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partialCount = partialCount;\n        }\n    }\n    set(props) {\n        // make sure the type is set first\n        if (Reflect.has(props, \"type\") && props.type) {\n            this.type = props.type;\n        }\n        // then set the rest\n        super.set(props);\n        return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n    _createNewOscillator(oscType) {\n        if (oscType !== this._sourceType) {\n            this._sourceType = oscType;\n            const OscConstructor = OmniOscillatorSourceMap[oscType];\n            // short delay to avoid clicks on the change\n            const now = this.now();\n            if (this._oscillator) {\n                const oldOsc = this._oscillator;\n                oldOsc.stop(now);\n                // dispose the old one\n                this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n            }\n            this._oscillator = new OscConstructor({\n                context: this.context,\n            });\n            this.frequency.connect(this._oscillator.frequency);\n            this.detune.connect(this._oscillator.detune);\n            this._oscillator.connect(this.output);\n            this._oscillator.onstop = () => this.onstop(this);\n            if (this.state === \"started\") {\n                this._oscillator.start(now);\n            }\n        }\n    }\n    get phase() {\n        return this._oscillator.phase;\n    }\n    set phase(phase) {\n        this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n    get sourceType() {\n        return this._sourceType;\n    }\n    set sourceType(sType) {\n        // the basetype defaults to sine\n        let baseType = \"sine\";\n        if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n            baseType = this._oscillator.type;\n        }\n        // set the type\n        if (sType === \"fm\") {\n            this.type = \"fm\" + baseType;\n        }\n        else if (sType === \"am\") {\n            this.type = \"am\" + baseType;\n        }\n        else if (sType === \"fat\") {\n            this.type = \"fat\" + baseType;\n        }\n        else if (sType === \"oscillator\") {\n            this.type = baseType;\n        }\n        else if (sType === \"pulse\") {\n            this.type = \"pulse\";\n        }\n        else if (sType === \"pwm\") {\n            this.type = \"pwm\";\n        }\n    }\n    _getOscType(osc, sourceType) {\n        return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator. See [[Oscillator.baseType]]\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n    get baseType() {\n        return this._oscillator.baseType;\n    }\n    set baseType(baseType) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\") &&\n            baseType !== \"pulse\" && baseType !== \"pwm\") {\n            this._oscillator.baseType = baseType;\n        }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * See [[PWMOscillator.width]]\n     */\n    get width() {\n        if (this._getOscType(this._oscillator, \"pulse\")) {\n            return this._oscillator.width;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get count() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.count;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set count(count) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n            this._oscillator.count = count;\n        }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get spread() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.spread;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set spread(spread) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n            this._oscillator.spread = spread;\n        }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get modulationType() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.modulationType;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set modulationType(mType) {\n        if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n            this._oscillator.modulationType = mType;\n        }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * See [[FMOscillator]].\n     */\n    get modulationIndex() {\n        if (this._getOscType(this._oscillator, \"fm\")) {\n            return this._oscillator.modulationIndex;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get harmonicity() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.harmonicity;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see [[PWMOscillator]]\n     * @min 0.1\n     * @max 5\n     */\n    get modulationFrequency() {\n        if (this._getOscType(this._oscillator, \"pwm\")) {\n            return this._oscillator.modulationFrequency;\n        }\n        else {\n            return undefined;\n        }\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.detune.dispose();\n        this.frequency.dispose();\n        this._oscillator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=OmniOscillator.js.map","import { assertRange } from \"./Debug\";\n/**\n * Assert that the number is in the given range.\n */\nexport function range(min, max = Infinity) {\n    const valueMap = new WeakMap();\n    return function (target, propertyKey) {\n        Reflect.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return valueMap.get(this);\n            },\n            set: function (newValue) {\n                assertRange(newValue, min, max);\n                valueMap.set(this, newValue);\n            }\n        });\n    };\n}\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\nexport function timeRange(min, max = Infinity) {\n    const valueMap = new WeakMap();\n    return function (target, propertyKey) {\n        Reflect.defineProperty(target, propertyKey, {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                return valueMap.get(this);\n            },\n            set: function (newValue) {\n                assertRange(this.toSeconds(newValue), min, max);\n                valueMap.set(this, newValue);\n            }\n        });\n    };\n}\n//# sourceMappingURL=Decorator.js.map","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source {\n    constructor() {\n        super(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n        this.name = \"Player\";\n        /**\n         * All of the active buffer source nodes\n         */\n        this._activeSources = new Set();\n        const options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n        this._buffer = new ToneAudioBuffer({\n            onload: this._onload.bind(this, options.onload),\n            onerror: options.onerror,\n            reverse: options.reverse,\n            url: options.url,\n        });\n        this.autostart = options.autostart;\n        this._loop = options.loop;\n        this._loopStart = options.loopStart;\n        this._loopEnd = options.loopEnd;\n        this._playbackRate = options.playbackRate;\n        this.fadeIn = options.fadeIn;\n        this.fadeOut = options.fadeOut;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            autostart: false,\n            fadeIn: 0,\n            fadeOut: 0,\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            onload: noOp,\n            onerror: noOp,\n            playbackRate: 1,\n            reverse: false,\n        });\n    }\n    /**\n     * Load the audio file as an audio buffer.\n     * Decodes the audio asynchronously and invokes\n     * the callback once the audio buffer loads.\n     * Note: this does not need to be called if a url\n     * was passed in to the constructor. Only use this\n     * if you want to manually load a new url.\n     * @param url The url of the buffer to load. Filetype support depends on the browser.\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._buffer.load(url);\n            this._onload();\n            return this;\n        });\n    }\n    /**\n     * Internal callback when the buffer is loaded.\n     */\n    _onload(callback = noOp) {\n        callback();\n        if (this.autostart) {\n            this.start();\n        }\n    }\n    /**\n     * Internal callback when the buffer is done playing.\n     */\n    _onSourceEnd(source) {\n        // invoke the onstop function\n        this.onstop(this);\n        // delete the source from the active sources\n        this._activeSources.delete(source);\n        if (this._activeSources.size === 0 && !this._synced &&\n            this._state.getValueAtTime(this.now()) === \"started\") {\n            this._state.setStateAtTime(\"stopped\", this.now());\n        }\n    }\n    /**\n     * Play the buffer at the given startTime. Optionally add an offset\n     * and/or duration which will play the buffer from a position\n     * within the buffer for the given duration.\n     *\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     */\n    start(time, offset, duration) {\n        super.start(time, offset, duration);\n        return this;\n    }\n    /**\n     * Internal start method\n     */\n    _start(startTime, offset, duration) {\n        // if it's a loop the default offset is the loopStart point\n        if (this._loop) {\n            offset = defaultArg(offset, this._loopStart);\n        }\n        else {\n            // otherwise the default offset is 0\n            offset = defaultArg(offset, 0);\n        }\n        // compute the values in seconds\n        let computedOffset = this.toSeconds(offset);\n        // if it's synced, it should factor in the playback rate for computing the offset\n        if (this._synced) {\n            computedOffset *= this._playbackRate;\n        }\n        // compute the duration which is either the passed in duration of the buffer.duration - offset\n        const origDuration = duration;\n        duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n        let computedDuration = this.toSeconds(duration);\n        // scale it by the playback rate\n        computedDuration = computedDuration / this._playbackRate;\n        // get the start time\n        startTime = this.toSeconds(startTime);\n        // make the source\n        const source = new ToneBufferSource({\n            url: this._buffer,\n            context: this.context,\n            fadeIn: this.fadeIn,\n            fadeOut: this.fadeOut,\n            loop: this._loop,\n            loopEnd: this._loopEnd,\n            loopStart: this._loopStart,\n            onended: this._onSourceEnd.bind(this),\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        // set the looping properties\n        if (!this._loop && !this._synced) {\n            // cancel the previous stop\n            this._state.cancel(startTime + computedDuration);\n            // if it's not looping, set the state change at the end of the sample\n            this._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n                implicitEnd: true,\n            });\n        }\n        // add it to the array of active sources\n        this._activeSources.add(source);\n        // start it\n        if (this._loop && isUndef(origDuration)) {\n            source.start(startTime, computedOffset);\n        }\n        else {\n            // subtract the fade out time\n            source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n        }\n    }\n    /**\n     * Stop playback.\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeSources.forEach(source => source.stop(computedTime));\n    }\n    /**\n     * Stop and then restart the player from the beginning (or offset)\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given,\n     * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n     */\n    restart(time, offset, duration) {\n        super.restart(time, offset, duration);\n        return this;\n    }\n    _restart(time, offset, duration) {\n        this._stop(time);\n        this._start(time, offset, duration);\n    }\n    /**\n     * Seek to a specific time in the player's buffer. If the\n     * source is no longer playing at that time, it will stop.\n     * @param offset The time to seek to.\n     * @param when The time for the seek event to occur.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n     * \tplayer.start();\n     * \t// seek to the offset in 1 second from now\n     * \tplayer.seek(0.4, \"+1\");\n     * }).toDestination();\n     */\n    seek(offset, when) {\n        const computedTime = this.toSeconds(when);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            const computedOffset = this.toSeconds(offset);\n            // if it's currently playing, stop it\n            this._stop(computedTime);\n            // restart it at the given time\n            this._start(computedTime, computedOffset);\n        }\n        return this;\n    }\n    /**\n     * Set the loop start and end. Will only loop if loop is set to true.\n     * @param loopStart The loop start time\n     * @param loopEnd The loop end time\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n     * // loop between the given points\n     * player.setLoopPoints(0.2, 0.3);\n     * player.loop = true;\n     * player.autostart = true;\n     */\n    setLoopPoints(loopStart, loopEnd) {\n        this.loopStart = loopStart;\n        this.loopEnd = loopEnd;\n        return this;\n    }\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n    get loopStart() {\n        return this._loopStart;\n    }\n    set loopStart(loopStart) {\n        this._loopStart = loopStart;\n        if (this.buffer.loaded) {\n            assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n        }\n        // get the current source\n        this._activeSources.forEach(source => {\n            source.loopStart = loopStart;\n        });\n    }\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n    get loopEnd() {\n        return this._loopEnd;\n    }\n    set loopEnd(loopEnd) {\n        this._loopEnd = loopEnd;\n        if (this.buffer.loaded) {\n            assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n        }\n        // get the current source\n        this._activeSources.forEach(source => {\n            source.loopEnd = loopEnd;\n        });\n    }\n    /**\n     * The audio buffer belonging to the player.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    set buffer(buffer) {\n        this._buffer.set(buffer);\n    }\n    /**\n     * If the buffer should loop once it's over.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n     * player.loop = true;\n     * player.autostart = true;\n     */\n    get loop() {\n        return this._loop;\n    }\n    set loop(loop) {\n        // if no change, do nothing\n        if (this._loop === loop) {\n            return;\n        }\n        this._loop = loop;\n        // set the loop of all of the sources\n        this._activeSources.forEach(source => {\n            source.loop = loop;\n        });\n        if (loop) {\n            // remove the next stopEvent\n            const stopEvent = this._state.getNextState(\"stopped\", this.now());\n            if (stopEvent) {\n                this._state.cancel(stopEvent.time);\n            }\n        }\n    }\n    /**\n     * Normal speed is 1. The pitch will change with the playback rate.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n     * // play at 1/4 speed\n     * player.playbackRate = 0.25;\n     * // play as soon as the buffer is loaded\n     * player.autostart = true;\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        const now = this.now();\n        // cancel the stop event since it's at a different time now\n        const stopEvent = this._state.getNextState(\"stopped\", now);\n        if (stopEvent && stopEvent.implicitEnd) {\n            this._state.cancel(stopEvent.time);\n            this._activeSources.forEach(source => source.cancelStop());\n        }\n        // set all the sources\n        this._activeSources.forEach(source => {\n            source.playbackRate.setValueAtTime(rate, now);\n        });\n    }\n    /**\n     * If the buffer should be reversed\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n     * player.autostart = true;\n     * player.reverse = true;\n     */\n    get reverse() {\n        return this._buffer.reverse;\n    }\n    set reverse(rev) {\n        this._buffer.reverse = rev;\n    }\n    /**\n     * If the buffer is loaded\n     */\n    get loaded() {\n        return this._buffer.loaded;\n    }\n    dispose() {\n        super.dispose();\n        // disconnect all of the players\n        this._activeSources.forEach(source => source.dispose());\n        this._activeSources.clear();\n        this._buffer.dispose();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Player.prototype, \"fadeIn\", void 0);\n__decorate([\n    timeRange(0)\n], Player.prototype, \"fadeOut\", void 0);\n//# sourceMappingURL=Player.js.map","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @offline 1.5 1\n * @example\n * const env = new Tone.Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 0.5,\n * \trelease: 0.8,\n * }).toDestination();\n * env.triggerAttackRelease(0.5);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n        this.name = \"Envelope\";\n        /**\n         * the signal which is output.\n         */\n        this._sig = new Signal({\n            context: this.context,\n            value: 0,\n        });\n        /**\n         * The output signal of the envelope\n         */\n        this.output = this._sig;\n        /**\n         * Envelope has no input\n         */\n        this.input = undefined;\n        const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n        this.attack = options.attack;\n        this.decay = options.decay;\n        this.sustain = options.sustain;\n        this.release = options.release;\n        this.attackCurve = options.attackCurve;\n        this.releaseCurve = options.releaseCurve;\n        this.decayCurve = options.decayCurve;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            attack: 0.01,\n            attackCurve: \"linear\",\n            decay: 0.1,\n            decayCurve: \"exponential\",\n            release: 1,\n            releaseCurve: \"exponential\",\n            sustain: 0.5,\n        });\n    }\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    get value() {\n        return this.getValueAtTime(this.now());\n    }\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n    _getCurve(curve, direction) {\n        if (isString(curve)) {\n            return curve;\n        }\n        else {\n            // look up the name in the curves array\n            let curveName;\n            for (curveName in EnvelopeCurves) {\n                if (EnvelopeCurves[curveName][direction] === curve) {\n                    return curveName;\n                }\n            }\n            // return the custom curve\n            return curve;\n        }\n    }\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n    _setCurve(name, direction, curve) {\n        // check if it's a valid type\n        if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n            const curveDef = EnvelopeCurves[curve];\n            if (isObject(curveDef)) {\n                if (name !== \"_decayCurve\") {\n                    this[name] = curveDef[direction];\n                }\n            }\n            else {\n                this[name] = curveDef;\n            }\n        }\n        else if (isArray(curve) && name !== \"_decayCurve\") {\n            this[name] = curve;\n        }\n        else {\n            throw new Error(\"Envelope: invalid curve: \" + curve);\n        }\n    }\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @offline 1 1\n     * @example\n     * const env = new Tone.Envelope(0.4).toDestination();\n     * env.attackCurve = \"linear\";\n     * env.triggerAttack();\n     */\n    get attackCurve() {\n        return this._getCurve(this._attackCurve, \"In\");\n    }\n    set attackCurve(curve) {\n        this._setCurve(\"_attackCurve\", \"In\", curve);\n    }\n    /**\n     * The shape of the release. See the attack curve types.\n     * @offline 1 1\n     * @example\n     * const env = new Tone.Envelope({\n     * \trelease: 0.8\n     * }).toDestination();\n     * env.triggerAttack();\n     * // release curve could also be defined by an array\n     * env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n     * env.triggerRelease(0.2);\n     */\n    get releaseCurve() {\n        return this._getCurve(this._releaseCurve, \"Out\");\n    }\n    set releaseCurve(curve) {\n        this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    }\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @offline 1 1\n     * @example\n     * const env = new Tone.Envelope({\n     * \tsustain: 0.1,\n     * \tdecay: 0.5\n     * }).toDestination();\n     * env.decayCurve = \"linear\";\n     * env.triggerAttack();\n     */\n    get decayCurve() {\n        return this._decayCurve;\n    }\n    set decayCurve(curve) {\n        assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n        this._decayCurve = curve;\n    }\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n    triggerAttack(time, velocity = 1) {\n        this.log(\"triggerAttack\", time, velocity);\n        time = this.toSeconds(time);\n        const originalAttack = this.toSeconds(this.attack);\n        let attack = originalAttack;\n        const decay = this.toSeconds(this.decay);\n        // check if it's not a complete attack\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            // subtract the current value from the attack time\n            const attackRate = 1 / attack;\n            const remainingDistance = 1 - currentValue;\n            // the attack is now the remaining time\n            attack = remainingDistance / attackRate;\n        }\n        // attack\n        if (attack < this.sampleTime) {\n            this._sig.cancelScheduledValues(time);\n            // case where the attack time is 0 should set instantly\n            this._sig.setValueAtTime(velocity, time);\n        }\n        else if (this._attackCurve === \"linear\") {\n            this._sig.linearRampTo(velocity, attack, time);\n        }\n        else if (this._attackCurve === \"exponential\") {\n            this._sig.targetRampTo(velocity, attack, time);\n        }\n        else {\n            this._sig.cancelAndHoldAtTime(time);\n            let curve = this._attackCurve;\n            // find the starting position in the curve\n            for (let i = 1; i < curve.length; i++) {\n                // the starting index is between the two values\n                if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n                    curve = this._attackCurve.slice(i);\n                    // the first index is the current value\n                    curve[0] = currentValue;\n                    break;\n                }\n            }\n            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n        }\n        // decay\n        if (decay && this.sustain < 1) {\n            const decayValue = velocity * this.sustain;\n            const decayStart = time + attack;\n            this.log(\"decay\", decayStart);\n            if (this._decayCurve === \"linear\") {\n                this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n            }\n            else {\n                this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n            }\n        }\n        return this;\n    }\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator({\n     * \ttype: \"sawtooth\"\n     * }).connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        time = this.toSeconds(time);\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            const release = this.toSeconds(this.release);\n            if (release < this.sampleTime) {\n                this._sig.setValueAtTime(0, time);\n            }\n            else if (this._releaseCurve === \"linear\") {\n                this._sig.linearRampTo(0, release, time);\n            }\n            else if (this._releaseCurve === \"exponential\") {\n                this._sig.targetRampTo(0, release, time);\n            }\n            else {\n                assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n                this._sig.cancelAndHoldAtTime(time);\n                this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n            }\n        }\n        return this;\n    }\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     * @example\n     * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n     * env.triggerAttackRelease(2);\n     * setInterval(() => console.log(env.getValueAtTime), 100);\n     */\n    getValueAtTime(time) {\n        return this._sig.getValueAtTime(time);\n    }\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n    triggerAttackRelease(duration, time, velocity = 1) {\n        time = this.toSeconds(time);\n        this.triggerAttack(time, velocity);\n        this.triggerRelease(time + this.toSeconds(duration));\n        return this;\n    }\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n    cancel(after) {\n        this._sig.cancelScheduledValues(this.toSeconds(after));\n        return this;\n    }\n    /**\n     * Connect the envelope to a destination node.\n     */\n    connect(destination, outputNumber = 0, inputNumber = 0) {\n        connectSignal(this, destination, outputNumber, inputNumber);\n        return this;\n    }\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve. Rescales the duration of the\n     * envelope to fit the length.\n     */\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const duration = length / this.context.sampleRate;\n            const context = new OfflineContext(1, duration, this.context.sampleRate);\n            // normalize the ADSR for the given duration with 20% sustain time\n            const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n            const envelopeDuration = attackPortion + this.toSeconds(this.release);\n            const sustainTime = envelopeDuration * 0.1;\n            const totalDuration = envelopeDuration + sustainTime;\n            // @ts-ignore\n            const clone = new this.constructor(Object.assign(this.get(), {\n                attack: duration * this.toSeconds(this.attack) / totalDuration,\n                decay: duration * this.toSeconds(this.decay) / totalDuration,\n                release: duration * this.toSeconds(this.release) / totalDuration,\n                context\n            }));\n            clone._sig.toDestination();\n            clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n            const buffer = yield context.render();\n            return buffer.getChannelData(0);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._sig.dispose();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"decay\", void 0);\n__decorate([\n    range(0, 1)\n], Envelope.prototype, \"sustain\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves = (() => {\n    const curveLen = 128;\n    let i;\n    let k;\n    // cosine curve\n    const cosineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        cosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n    }\n    // ripple curve\n    const rippleCurve = [];\n    const rippleCurveFreq = 6.4;\n    for (i = 0; i < curveLen - 1; i++) {\n        k = (i / (curveLen - 1));\n        const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n        rippleCurve[i] = sineWave / 10 + k * 0.83;\n    }\n    rippleCurve[curveLen - 1] = 1;\n    // stairs curve\n    const stairsCurve = [];\n    const steps = 5;\n    for (i = 0; i < curveLen; i++) {\n        stairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n    }\n    // in-out easing curve\n    const sineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n    // a bounce curve\n    const bounceCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        const freq = Math.pow(k, 3) * 4 + 0.2;\n        const val = Math.cos(freq * Math.PI * 2 * k);\n        bounceCurve[i] = Math.abs(val * (1 - k));\n    }\n    /**\n     * Invert a value curve to make it work for the release\n     */\n    function invertCurve(curve) {\n        const out = new Array(curve.length);\n        for (let j = 0; j < curve.length; j++) {\n            out[j] = 1 - curve[j];\n        }\n        return out;\n    }\n    /**\n     * reverse the curve\n     */\n    function reverseCurve(curve) {\n        return curve.slice(0).reverse();\n    }\n    /**\n     * attack and release curve arrays\n     */\n    return {\n        bounce: {\n            In: invertCurve(bounceCurve),\n            Out: bounceCurve,\n        },\n        cosine: {\n            In: cosineCurve,\n            Out: reverseCurve(cosineCurve),\n        },\n        exponential: \"exponential\",\n        linear: \"linear\",\n        ripple: {\n            In: rippleCurve,\n            Out: invertCurve(rippleCurve),\n        },\n        sine: {\n            In: sineCurve,\n            Out: invertCurve(sineCurve),\n        },\n        step: {\n            In: stairsCurve,\n            Out: invertCurve(stairsCurve),\n        },\n    };\n})();\n//# sourceMappingURL=Envelope.js.map","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\nexport class Instrument extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Instrument.getDefaults(), arguments));\n        /**\n         * Keep track of all events scheduled to the transport\n         * when the instrument is 'synced'\n         */\n        this._scheduledEvents = [];\n        /**\n         * If the instrument is currently synced\n         */\n        this._synced = false;\n        this._original_triggerAttack = this.triggerAttack;\n        this._original_triggerRelease = this.triggerRelease;\n        const options = optionsFromArguments(Instrument.getDefaults(), arguments);\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            volume: 0,\n        });\n    }\n    /**\n     * Sync the instrument to the Transport. All subsequent calls of\n     * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n     * @example\n     * const fmSynth = new Tone.FMSynth().toDestination();\n     * fmSynth.volume.value = -6;\n     * fmSynth.sync();\n     * // schedule 3 notes when the transport first starts\n     * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n     * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n     * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n     * // start the transport to hear the notes\n     * Tone.Transport.start();\n     */\n    sync() {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 0);\n        }\n        return this;\n    }\n    /**\n     * Wrap the given method so that it can be synchronized\n     * @param method Which method to wrap and sync\n     * @param  timePosition What position the time argument appears in\n     */\n    _syncMethod(method, timePosition) {\n        const originalMethod = this[\"_original_\" + method] = this[method];\n        this[method] = (...args) => {\n            const time = args[timePosition];\n            const id = this.context.transport.schedule((t) => {\n                args[timePosition] = t;\n                originalMethod.apply(this, args);\n            }, time);\n            this._scheduledEvents.push(id);\n        };\n    }\n    /**\n     * Unsync the instrument from the Transport\n     */\n    unsync() {\n        this._scheduledEvents.forEach(id => this.context.transport.clear(id));\n        this._scheduledEvents = [];\n        if (this._synced) {\n            this._synced = false;\n            this.triggerAttack = this._original_triggerAttack;\n            this.triggerRelease = this._original_triggerRelease;\n        }\n        return this;\n    }\n    /**\n     * Trigger the attack and then the release after the duration.\n     * @param  note     The note to trigger.\n     * @param  duration How long the note should be held for before\n     *                         triggering the release. This value must be greater than 0.\n     * @param time  When the note should be triggered.\n     * @param  velocity The velocity the note should be triggered at.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger \"C4\" for the duration of an 8th note\n     * synth.triggerAttackRelease(\"C4\", \"8n\");\n     */\n    triggerAttackRelease(note, duration, time, velocity) {\n        const computedTime = this.toSeconds(time);\n        const computedDuration = this.toSeconds(duration);\n        this.triggerAttack(note, computedTime, velocity);\n        this.triggerRelease(computedTime + computedDuration);\n        return this;\n    }\n    /**\n     * clean up\n     * @returns {Instrument} this\n     */\n    dispose() {\n        super.dispose();\n        this._volume.dispose();\n        this.unsync();\n        this._scheduledEvents = [];\n        return this;\n    }\n}\n//# sourceMappingURL=Instrument.js.map","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport class Monophonic extends Instrument {\n    constructor() {\n        super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n        const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n        this.portamento = options.portamento;\n        this.onsilence = options.onsilence;\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            detune: 0,\n            onsilence: noOp,\n            portamento: 0,\n        });\n    }\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    triggerAttack(note, time, velocity = 1) {\n        this.log(\"triggerAttack\", note, time, velocity);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeAttack(seconds, velocity);\n        this.setNote(note, seconds);\n        return this;\n    }\n    /**\n     * Trigger the release portion of the envelope\n     * @param  time If no time is given, the release happens immediatly\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeRelease(seconds);\n        return this;\n    }\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n    setNote(note, time) {\n        const computedTime = this.toSeconds(time);\n        const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n        if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n            const portTime = this.toSeconds(this.portamento);\n            this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n        }\n        else {\n            this.frequency.setValueAtTime(computedFrequency, computedTime);\n        }\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Monophonic.prototype, \"portamento\", void 0);\n//# sourceMappingURL=Monophonic.js.map","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @offline 1.5 1\n * @example\n * const ampEnv = new Tone.AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Tone.Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n    constructor() {\n        super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n        this.name = \"AmplitudeEnvelope\";\n        this._gainNode = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        this.output = this._gainNode;\n        this.input = this._gainNode;\n        this._sig.connect(this._gainNode.gain);\n        this.output = this._gainNode;\n        this.input = this._gainNode;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._gainNode.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AmplitudeEnvelope.js.map","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth extends Monophonic {\n    constructor() {\n        super(optionsFromArguments(Synth.getDefaults(), arguments));\n        this.name = \"Synth\";\n        const options = optionsFromArguments(Synth.getDefaults(), arguments);\n        this.oscillator = new OmniOscillator(Object.assign({\n            context: this.context,\n            detune: options.detune,\n            onstop: () => this.onsilence(this),\n        }, options.oscillator));\n        this.frequency = this.oscillator.frequency;\n        this.detune = this.oscillator.detune;\n        this.envelope = new AmplitudeEnvelope(Object.assign({\n            context: this.context,\n        }, options.envelope));\n        // connect the oscillators to the output\n        this.oscillator.chain(this.envelope, this.output);\n        readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Monophonic.getDefaults(), {\n            envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n                attack: 0.005,\n                decay: 0.1,\n                release: 1,\n                sustain: 0.3,\n            }),\n            oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n                type: \"triangle\",\n            }),\n        });\n    }\n    /**\n     * start the attack portion of the envelope\n     * @param time the time the attack should start\n     * @param velocity the velocity of the note (0-1)\n     */\n    _triggerEnvelopeAttack(time, velocity) {\n        // the envelopes\n        this.envelope.triggerAttack(time, velocity);\n        this.oscillator.start(time);\n        // if there is no release portion, stop the oscillator\n        if (this.envelope.sustain === 0) {\n            const computedAttack = this.toSeconds(this.envelope.attack);\n            const computedDecay = this.toSeconds(this.envelope.decay);\n            this.oscillator.stop(time + computedAttack + computedDecay);\n        }\n    }\n    /**\n     * start the release portion of the envelope\n     * @param time the time the release should start\n     */\n    _triggerEnvelopeRelease(time) {\n        this.envelope.triggerRelease(time);\n        this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n    }\n    getLevelAtTime(time) {\n        time = this.toSeconds(time);\n        return this.envelope.getValueAtTime(time);\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this.oscillator.dispose();\n        this.envelope.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Synth.js.map","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth {\n    constructor() {\n        super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n        this.name = \"MembraneSynth\";\n        /**\n         * Portamento is ignored in this synth. use pitch decay instead.\n         */\n        this.portamento = 0;\n        const options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n        this.pitchDecay = options.pitchDecay;\n        this.octaves = options.octaves;\n        readOnly(this, [\"oscillator\", \"envelope\"]);\n    }\n    static getDefaults() {\n        return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n            envelope: {\n                attack: 0.001,\n                attackCurve: \"exponential\",\n                decay: 0.4,\n                release: 1.4,\n                sustain: 0.01,\n            },\n            octaves: 10,\n            oscillator: {\n                type: \"sine\",\n            },\n            pitchDecay: 0.05,\n        });\n    }\n    setNote(note, time) {\n        const seconds = this.toSeconds(time);\n        const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n        const maxNote = hertz * this.octaves;\n        this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n        this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        return this;\n    }\n}\n__decorate([\n    range(0)\n], MembraneSynth.prototype, \"octaves\", void 0);\n__decorate([\n    timeRange(0)\n], MembraneSynth.prototype, \"pitchDecay\", void 0);\n//# sourceMappingURL=MembraneSynth.js.map","/**\n * All of the classes or functions which are loaded into the AudioWorkletGlobalScope\n */\nconst workletContext = new Set();\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\nexport function addToWorklet(classOrFunction) {\n    workletContext.add(classOrFunction);\n}\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\nexport function registerProcessor(name, classDesc) {\n    const processor = /* javascript */ `registerProcessor(\"${name}\", ${classDesc})`;\n    workletContext.add(processor);\n}\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\nexport function getWorkletGlobalScope() {\n    return Array.from(workletContext).join(\"\\n\");\n}\n//# sourceMappingURL=WorkletGlobalScope.js.map","import { addToWorklet } from \"./WorkletGlobalScope\";\nconst toneAudioWorkletProcessor = /* javascript */ `\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it's disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === \"dispose\") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n`;\naddToWorklet(toneAudioWorkletProcessor);\n//# sourceMappingURL=ToneAudioWorkletProcessor.worklet.js.map","import \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\naddToWorklet(singleIOProcess);\n//# sourceMappingURL=SingleIOProcessor.worklet.js.map","import { addToWorklet } from \"./WorkletGlobalScope\";\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\naddToWorklet(delayLine);\n//# sourceMappingURL=DelayLine.worklet.js.map","import \"../../core/worklet/SingleIOProcessor.worklet\";\nimport \"../../core/worklet/DelayLine.worklet\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"feedback-comb-filter\";\nconst feedbackCombFilter = /* javascript */ `\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"delayTime\",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}, {\n\t\t\t\tname: \"feedback\",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n`;\nregisterProcessor(workletName, feedbackCombFilter);\n//# sourceMappingURL=FeedbackCombFilter.worklet.js.map","import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\nexport class Sampler extends Instrument {\n    constructor() {\n        super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n        this.name = \"Sampler\";\n        /**\n         * The object of all currently playing BufferSources\n         */\n        this._activeSources = new Map();\n        const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        const urlMap = {};\n        Object.keys(options.urls).forEach((note) => {\n            const noteNumber = parseInt(note, 10);\n            assert(isNote(note)\n                || (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n            if (isNote(note)) {\n                // convert the note name to MIDI\n                const mid = new FrequencyClass(this.context, note).toMidi();\n                urlMap[mid] = options.urls[note];\n            }\n            else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n                // otherwise if it's numbers assume it's midi\n                urlMap[noteNumber] = options.urls[noteNumber];\n            }\n        });\n        this._buffers = new ToneAudioBuffers({\n            urls: urlMap,\n            onload: options.onload,\n            baseUrl: options.baseUrl,\n            onerror: options.onerror,\n        });\n        this.attack = options.attack;\n        this.release = options.release;\n        this.curve = options.curve;\n        // invoke the callback if it's already loaded\n        if (this._buffers.loaded) {\n            // invoke onload deferred\n            Promise.resolve().then(options.onload);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            attack: 0,\n            baseUrl: \"\",\n            curve: \"exponential\",\n            onload: noOp,\n            onerror: noOp,\n            release: 0.1,\n            urls: {},\n        });\n    }\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    _findClosest(midi) {\n        // searches within 8 octaves of the given midi note\n        const MAX_INTERVAL = 96;\n        let interval = 0;\n        while (interval < MAX_INTERVAL) {\n            // check above and below\n            if (this._buffers.has(midi + interval)) {\n                return -interval;\n            }\n            else if (this._buffers.has(midi - interval)) {\n                return interval;\n            }\n            interval++;\n        }\n        throw new Error(`No available buffers for note: ${midi}`);\n    }\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n    triggerAttack(notes, time, velocity = 1) {\n        this.log(\"triggerAttack\", notes, time, velocity);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(note => {\n            const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n            const midi = Math.round(midiFloat);\n            const remainder = midiFloat - midi;\n            // find the closest note pitch\n            const difference = this._findClosest(midi);\n            const closestNote = midi - difference;\n            const buffer = this._buffers.get(closestNote);\n            const playbackRate = intervalToFrequencyRatio(difference + remainder);\n            // play that note\n            const source = new ToneBufferSource({\n                url: buffer,\n                context: this.context,\n                curve: this.curve,\n                fadeIn: this.attack,\n                fadeOut: this.release,\n                playbackRate,\n            }).connect(this.output);\n            source.start(time, 0, buffer.duration / playbackRate, velocity);\n            // add it to the active sources\n            if (!isArray(this._activeSources.get(midi))) {\n                this._activeSources.set(midi, []);\n            }\n            this._activeSources.get(midi).push(source);\n            // remove it when it's done\n            source.onended = () => {\n                if (this._activeSources && this._activeSources.has(midi)) {\n                    const sources = this._activeSources.get(midi);\n                    const index = sources.indexOf(source);\n                    if (index !== -1) {\n                        sources.splice(index, 1);\n                    }\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n    triggerRelease(notes, time) {\n        this.log(\"triggerRelease\", notes, time);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(note => {\n            const midi = new FrequencyClass(this.context, note).toMidi();\n            // find the note\n            if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n                const sources = this._activeSources.get(midi);\n                time = this.toSeconds(time);\n                sources.forEach(source => {\n                    source.stop(time);\n                });\n                this._activeSources.set(midi, []);\n            }\n        });\n        return this;\n    }\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n    releaseAll(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeSources.forEach(sources => {\n            while (sources.length) {\n                const source = sources.shift();\n                source.stop(computedTime);\n            }\n        });\n        return this;\n    }\n    sync() {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n        return this;\n    }\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n    triggerAttackRelease(notes, duration, time, velocity = 1) {\n        const computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"notes must be an array when duration is array\");\n            notes.forEach((note, index) => {\n                const d = duration[Math.min(index, duration.length - 1)];\n                this.triggerRelease(note, computedTime + this.toSeconds(d));\n            });\n        }\n        else {\n            this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n        }\n        return this;\n    }\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n    add(note, url, callback) {\n        assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n        if (isNote(note)) {\n            // convert the note name to MIDI\n            const mid = new FrequencyClass(this.context, note).toMidi();\n            this._buffers.add(mid, url, callback);\n        }\n        else {\n            // otherwise if it's numbers assume it's midi\n            this._buffers.add(note, url, callback);\n        }\n        return this;\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n    get loaded() {\n        return this._buffers.loaded;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffers.dispose();\n        this._activeSources.forEach(sources => {\n            sources.forEach(source => source.dispose());\n        });\n        this._activeSources.clear();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"release\", void 0);\n//# sourceMappingURL=Sampler.js.map","import \"../core/clock/Transport\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * const chordEvent = new Tone.ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n        this.name = \"ToneEvent\";\n        /**\n         * Tracks the scheduled events\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * A delay time from when the event is scheduled to start\n         */\n        this._startOffset = 0;\n        const options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n        this._loop = options.loop;\n        this.callback = options.callback;\n        this.value = options.value;\n        this._loopStart = this.toTicks(options.loopStart);\n        this._loopEnd = this.toTicks(options.loopEnd);\n        this._playbackRate = options.playbackRate;\n        this._probability = options.probability;\n        this._humanize = options.humanize;\n        this.mute = options.mute;\n        this._playbackRate = options.playbackRate;\n        this._state.increasing = true;\n        // schedule the events for the first time\n        this._rescheduleEvents();\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            humanize: false,\n            loop: false,\n            loopEnd: \"1m\",\n            loopStart: 0,\n            mute: false,\n            playbackRate: 1,\n            probability: 1,\n            value: null,\n        });\n    }\n    /**\n     * Reschedule all of the events along the timeline\n     * with the updated values.\n     * @param after Only reschedules events after the given time.\n     */\n    _rescheduleEvents(after = -1) {\n        // if no argument is given, schedules all of the events\n        this._state.forEachFrom(after, event => {\n            let duration;\n            if (event.state === \"started\") {\n                if (event.id !== -1) {\n                    this.context.transport.clear(event.id);\n                }\n                const startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n                if (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n                    duration = Infinity;\n                    if (isNumber(this._loop)) {\n                        duration = (this._loop) * this._getLoopDuration();\n                    }\n                    const nextEvent = this._state.getAfter(startTick);\n                    if (nextEvent !== null) {\n                        duration = Math.min(duration, nextEvent.time - startTick);\n                    }\n                    if (duration !== Infinity) {\n                        // schedule a stop since it's finite duration\n                        this._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id: -1 });\n                        duration = new TicksClass(this.context, duration);\n                    }\n                    const interval = new TicksClass(this.context, this._getLoopDuration());\n                    event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n                }\n                else {\n                    event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n                }\n            }\n        });\n    }\n    /**\n     * Returns the playback state of the note, either \"started\" or \"stopped\".\n     */\n    get state() {\n        return this._state.getValueAtTime(this.context.transport.ticks);\n    }\n    /**\n     * The start from the scheduled start time.\n     */\n    get startOffset() {\n        return this._startOffset;\n    }\n    set startOffset(offset) {\n        this._startOffset = offset;\n    }\n    /**\n     * The probability of the notes being triggered.\n     */\n    get probability() {\n        return this._probability;\n    }\n    set probability(prob) {\n        this._probability = prob;\n    }\n    /**\n     * If set to true, will apply small random variation\n     * to the callback time. If the value is given as a time, it will randomize\n     * by that amount.\n     * @example\n     * const event = new Tone.ToneEvent();\n     * event.humanize = true;\n     */\n    get humanize() {\n        return this._humanize;\n    }\n    set humanize(variation) {\n        this._humanize = variation;\n    }\n    /**\n     * Start the note at the given time.\n     * @param  time  When the event should start.\n     */\n    start(time) {\n        const ticks = this.toTicks(time);\n        if (this._state.getValueAtTime(ticks) === \"stopped\") {\n            this._state.add({\n                id: -1,\n                state: \"started\",\n                time: ticks,\n            });\n            this._rescheduleEvents(ticks);\n        }\n        return this;\n    }\n    /**\n     * Stop the Event at the given time.\n     * @param  time  When the event should stop.\n     */\n    stop(time) {\n        this.cancel(time);\n        const ticks = this.toTicks(time);\n        if (this._state.getValueAtTime(ticks) === \"started\") {\n            this._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n            const previousEvent = this._state.getBefore(ticks);\n            let reschedulTime = ticks;\n            if (previousEvent !== null) {\n                reschedulTime = previousEvent.time;\n            }\n            this._rescheduleEvents(reschedulTime);\n        }\n        return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n    cancel(time) {\n        time = defaultArg(time, -Infinity);\n        const ticks = this.toTicks(time);\n        this._state.forEachFrom(ticks, event => {\n            this.context.transport.clear(event.id);\n        });\n        this._state.cancel(ticks);\n        return this;\n    }\n    /**\n     * The callback function invoker. Also\n     * checks if the Event is done playing\n     * @param  time  The time of the event in seconds\n     */\n    _tick(time) {\n        const ticks = this.context.transport.getTicksAtTime(time);\n        if (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n            if (this.probability < 1 && Math.random() > this.probability) {\n                return;\n            }\n            if (this.humanize) {\n                let variation = 0.02;\n                if (!isBoolean(this.humanize)) {\n                    variation = this.toSeconds(this.humanize);\n                }\n                time += (Math.random() * 2 - 1) * variation;\n            }\n            this.callback(time, this.value);\n        }\n    }\n    /**\n     * Get the duration of the loop.\n     */\n    _getLoopDuration() {\n        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n    }\n    /**\n     * If the note should loop or not\n     * between ToneEvent.loopStart and\n     * ToneEvent.loopEnd. If set to true,\n     * the event will loop indefinitely,\n     * if set to a number greater than 1\n     * it will play a specific number of\n     * times, if set to false, 0 or 1, the\n     * part will only play once.\n     */\n    get loop() {\n        return this._loop;\n    }\n    set loop(loop) {\n        this._loop = loop;\n        this._rescheduleEvents();\n    }\n    /**\n     * The playback rate of the note. Defaults to 1.\n     * @example\n     * const note = new Tone.ToneEvent();\n     * note.loop = true;\n     * // repeat the note twice as fast\n     * note.playbackRate = 2;\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        this._rescheduleEvents();\n    }\n    /**\n     * The loopEnd point is the time the event will loop\n     * if ToneEvent.loop is true.\n     */\n    get loopEnd() {\n        return new TicksClass(this.context, this._loopEnd).toSeconds();\n    }\n    set loopEnd(loopEnd) {\n        this._loopEnd = this.toTicks(loopEnd);\n        if (this._loop) {\n            this._rescheduleEvents();\n        }\n    }\n    /**\n     * The time when the loop should start.\n     */\n    get loopStart() {\n        return new TicksClass(this.context, this._loopStart).toSeconds();\n    }\n    set loopStart(loopStart) {\n        this._loopStart = this.toTicks(loopStart);\n        if (this._loop) {\n            this._rescheduleEvents();\n        }\n    }\n    /**\n     * The current progress of the loop interval.\n     * Returns 0 if the event is not started yet or\n     * it is not set to loop.\n     */\n    get progress() {\n        if (this._loop) {\n            const ticks = this.context.transport.ticks;\n            const lastEvent = this._state.get(ticks);\n            if (lastEvent !== null && lastEvent.state === \"started\") {\n                const loopDuration = this._getLoopDuration();\n                const progress = (ticks - lastEvent.time) % loopDuration;\n                return progress / loopDuration;\n            }\n            else {\n                return 0;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    dispose() {\n        super.dispose();\n        this.cancel();\n        this._state.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneEvent.js.map","import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n        this.name = \"Loop\";\n        const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n        this._event = new ToneEvent({\n            context: this.context,\n            callback: this._tick.bind(this),\n            loop: true,\n            loopEnd: options.interval,\n            playbackRate: options.playbackRate,\n            probability: options.probability\n        });\n        this.callback = options.callback;\n        // set the iterations\n        this.iterations = options.iterations;\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            interval: \"4n\",\n            callback: noOp,\n            playbackRate: 1,\n            iterations: Infinity,\n            probability: 1,\n            mute: false,\n            humanize: false\n        });\n    }\n    /**\n     * Start the loop at the specified time along the Transport's timeline.\n     * @param  time  When to start the Loop.\n     */\n    start(time) {\n        this._event.start(time);\n        return this;\n    }\n    /**\n     * Stop the loop at the given time.\n     * @param  time  When to stop the Loop.\n     */\n    stop(time) {\n        this._event.stop(time);\n        return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n    cancel(time) {\n        this._event.cancel(time);\n        return this;\n    }\n    /**\n     * Internal function called when the notes should be called\n     * @param time  The time the event occurs\n     */\n    _tick(time) {\n        this.callback(time);\n    }\n    /**\n     * The state of the Loop, either started or stopped.\n     */\n    get state() {\n        return this._event.state;\n    }\n    /**\n     * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n     */\n    get progress() {\n        return this._event.progress;\n    }\n    /**\n     * The time between successive callbacks.\n     * @example\n     * const loop = new Tone.Loop();\n     * loop.interval = \"8n\"; // loop every 8n\n     */\n    get interval() {\n        return this._event.loopEnd;\n    }\n    set interval(interval) {\n        this._event.loopEnd = interval;\n    }\n    /**\n     * The playback rate of the loop. The normal playback rate is 1 (no change).\n     * A `playbackRate` of 2 would be twice as fast.\n     */\n    get playbackRate() {\n        return this._event.playbackRate;\n    }\n    set playbackRate(rate) {\n        this._event.playbackRate = rate;\n    }\n    /**\n     * Random variation +/-0.01s to the scheduled time.\n     * Or give it a time value which it will randomize by.\n     */\n    get humanize() {\n        return this._event.humanize;\n    }\n    set humanize(variation) {\n        this._event.humanize = variation;\n    }\n    /**\n     * The probably of the callback being invoked.\n     */\n    get probability() {\n        return this._event.probability;\n    }\n    set probability(prob) {\n        this._event.probability = prob;\n    }\n    /**\n     * Muting the Loop means that no callbacks are invoked.\n     */\n    get mute() {\n        return this._event.mute;\n    }\n    set mute(mute) {\n        this._event.mute = mute;\n    }\n    /**\n     * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n     */\n    get iterations() {\n        if (this._event.loop === true) {\n            return Infinity;\n        }\n        else {\n            return this._event.loop;\n        }\n    }\n    set iterations(iters) {\n        if (iters === Infinity) {\n            this._event.loop = true;\n        }\n        else {\n            this._event.loop = iters;\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._event.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Loop.js.map","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @offline 0.5 2\n * @example\n * // move the input signal from right to left\n * const panner = new Tone.Panner(1).toDestination();\n * panner.pan.rampTo(-1, 0.5);\n * const osc = new Tone.Oscillator(100).connect(panner).start();\n * @category Component\n */\nexport class Panner extends ToneAudioNode {\n    constructor() {\n        super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n        this.name = \"Panner\";\n        /**\n         * the panner node\n         */\n        this._panner = this.context.createStereoPanner();\n        this.input = this._panner;\n        this.output = this._panner;\n        const options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n        this.pan = new Param({\n            context: this.context,\n            param: this._panner.pan,\n            value: options.pan,\n            minValue: -1,\n            maxValue: 1,\n        });\n        // this is necessary for standardized-audio-context\n        // doesn't make any difference for the native AudioContext\n        // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n        this._panner.channelCount = options.channelCount;\n        this._panner.channelCountMode = \"explicit\";\n        // initial value\n        readOnly(this, \"pan\");\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            pan: 0,\n            channelCount: 1,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._panner.disconnect();\n        this.pan.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Panner.js.map","import \"../core/worklet/SingleIOProcessor.worklet\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"bit-crusher\";\nexport const bitCrusherWorklet = /* javascript */ `\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n`;\nregisterProcessor(workletName, bitCrusherWorklet);\n//# sourceMappingURL=BitCrusher.worklet.js.map","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n        this.name = \"Solo\";\n        const options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n        this.input = this.output = new Gain({\n            context: this.context,\n        });\n        if (!Solo._allSolos.has(this.context)) {\n            Solo._allSolos.set(this.context, new Set());\n        }\n        Solo._allSolos.get(this.context).add(this);\n        // set initially\n        this.solo = options.solo;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            solo: false,\n        });\n    }\n    /**\n     * Isolates this instance and mutes all other instances of Solo.\n     * Only one instance can be soloed at a time. A soloed\n     * instance will report `solo=false` when another instance is soloed.\n     */\n    get solo() {\n        return this._isSoloed();\n    }\n    set solo(solo) {\n        if (solo) {\n            this._addSolo();\n        }\n        else {\n            this._removeSolo();\n        }\n        Solo._allSolos.get(this.context).forEach(instance => instance._updateSolo());\n    }\n    /**\n     * If the current instance is muted, i.e. another instance is soloed\n     */\n    get muted() {\n        return this.input.gain.value === 0;\n    }\n    /**\n     * Add this to the soloed array\n     */\n    _addSolo() {\n        if (!Solo._soloed.has(this.context)) {\n            Solo._soloed.set(this.context, new Set());\n        }\n        Solo._soloed.get(this.context).add(this);\n    }\n    /**\n     * Remove this from the soloed array\n     */\n    _removeSolo() {\n        if (Solo._soloed.has(this.context)) {\n            Solo._soloed.get(this.context).delete(this);\n        }\n    }\n    /**\n     * Is this on the soloed array\n     */\n    _isSoloed() {\n        return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);\n    }\n    /**\n     * Returns true if no one is soloed\n     */\n    _noSolos() {\n        // either does not have any soloed added\n        return !Solo._soloed.has(this.context) ||\n            // or has a solo set but doesn't include any items\n            (Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0);\n    }\n    /**\n     * Solo the current instance and unsolo all other instances.\n     */\n    _updateSolo() {\n        if (this._isSoloed()) {\n            this.input.gain.value = 1;\n        }\n        else if (this._noSolos()) {\n            // no one is soloed\n            this.input.gain.value = 1;\n        }\n        else {\n            this.input.gain.value = 0;\n        }\n    }\n    dispose() {\n        super.dispose();\n        Solo._allSolos.get(this.context).delete(this);\n        this._removeSolo();\n        return this;\n    }\n}\n/**\n * Hold all of the solo'ed tracks belonging to a specific context\n */\nSolo._allSolos = new Map();\n/**\n * Hold the currently solo'ed instance(s)\n */\nSolo._soloed = new Map();\n//# sourceMappingURL=Solo.js.map","import { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n        this.name = \"PanVol\";\n        const options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n        this._panner = this.input = new Panner({\n            context: this.context,\n            pan: options.pan,\n            channelCount: options.channelCount,\n        });\n        this.pan = this._panner.pan;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        // connections\n        this._panner.connect(this._volume);\n        this.mute = options.mute;\n        readOnly(this, [\"pan\", \"volume\"]);\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            pan: 0,\n            volume: 0,\n            channelCount: 1,\n        });\n    }\n    /**\n     * Mute/unmute the volume\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    dispose() {\n        super.dispose();\n        this._panner.dispose();\n        this.pan.dispose();\n        this._volume.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PanVol.js.map","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls.\n * See [[PanVol]] and [[Solo]]\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n        this.name = \"Channel\";\n        const options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n        this._solo = this.input = new Solo({\n            solo: options.solo,\n            context: this.context,\n        });\n        this._panVol = this.output = new PanVol({\n            context: this.context,\n            pan: options.pan,\n            volume: options.volume,\n            mute: options.mute,\n        });\n        this.pan = this._panVol.pan;\n        this.volume = this._panVol.volume;\n        this._solo.connect(this._panVol);\n        readOnly(this, [\"pan\", \"volume\"]);\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            pan: 0,\n            volume: 0,\n            mute: false,\n            solo: false\n        });\n    }\n    /**\n     * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n     */\n    get solo() {\n        return this._solo.solo;\n    }\n    set solo(solo) {\n        this._solo.solo = solo;\n    }\n    /**\n     * If the current instance is muted, i.e. another instance is soloed,\n     * or the channel is muted\n     */\n    get muted() {\n        return this._solo.muted || this.mute;\n    }\n    /**\n     * Mute/unmute the volume\n     */\n    get mute() {\n        return this._panVol.mute;\n    }\n    set mute(mute) {\n        this._panVol.mute = mute;\n    }\n    /**\n     * Get the gain node belonging to the bus name. Create it if\n     * it doesn't exist\n     * @param name The bus name\n     */\n    _getBus(name) {\n        if (!Channel.buses.has(name)) {\n            Channel.buses.set(name, new Gain({ context: this.context }));\n        }\n        return Channel.buses.get(name);\n    }\n    /**\n     * Send audio to another channel using a string. `send` is a lot like\n     * [[connect]], except it uses a string instead of an object. This can\n     * be useful in large applications to decouple sections since [[send]]\n     * and [[receive]] can be invoked separately in order to connect an object\n     * @param name The channel name to send the audio\n     * @param volume The amount of the signal to send.\n     * \tDefaults to 0db, i.e. send the entire signal\n     * @returns Returns the gain node of this connection.\n     */\n    send(name, volume = 0) {\n        const bus = this._getBus(name);\n        const sendKnob = new Gain({\n            context: this.context,\n            units: \"decibels\",\n            gain: volume,\n        });\n        this.connect(sendKnob);\n        sendKnob.connect(bus);\n        return sendKnob;\n    }\n    /**\n     * Receive audio from a channel which was connected with [[send]].\n     * @param name The channel name to receive audio from.\n     */\n    receive(name) {\n        const bus = this._getBus(name);\n        bus.connect(this);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._panVol.dispose();\n        this.pan.dispose();\n        this.volume.dispose();\n        this._solo.dispose();\n        return this;\n    }\n}\n/**\n * Store the send/receive channels by name.\n */\nChannel.buses = new Map();\n//# sourceMappingURL=Channel.js.map","import { ToneAudioNode } from \"./ToneAudioNode\";\nimport { Param } from \"./Param\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you\n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context.\n */\nexport class Listener extends ToneAudioNode {\n    constructor() {\n        super(...arguments);\n        this.name = \"Listener\";\n        this.positionX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionX,\n        });\n        this.positionY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionY,\n        });\n        this.positionZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.positionZ,\n        });\n        this.forwardX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardX,\n        });\n        this.forwardY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardY,\n        });\n        this.forwardZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.forwardZ,\n        });\n        this.upX = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upX,\n        });\n        this.upY = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upY,\n        });\n        this.upZ = new Param({\n            context: this.context,\n            param: this.context.rawContext.listener.upZ,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            positionX: 0,\n            positionY: 0,\n            positionZ: 0,\n            forwardX: 0,\n            forwardY: 0,\n            forwardZ: -1,\n            upX: 0,\n            upY: 1,\n            upZ: 0,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.positionX.dispose();\n        this.positionY.dispose();\n        this.positionZ.dispose();\n        this.forwardX.dispose();\n        this.forwardY.dispose();\n        this.forwardZ.dispose();\n        this.upX.dispose();\n        this.upY.dispose();\n        this.upZ.dispose();\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.listener = new Listener({ context });\n});\nonContextClose(context => {\n    context.listener.dispose();\n});\n//# sourceMappingURL=Listener.js.map","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer\";\nexport { start } from \"./core/Global\";\nexport { supported } from \"./core/context/AudioContext\";\n/**\n * The current audio context time of the global [[Context]].\n * See [[Context.now]]\n * @category Core\n */\nexport function now() {\n    return getContext().now();\n}\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @category Core\n */\nexport function immediate() {\n    return getContext().immediate();\n}\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport const Transport = getContext().transport;\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport function getTransport() {\n    return getContext().transport;\n}\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport const Destination = getContext().destination;\n/**\n * @deprecated Use [[Destination]]\n */\nexport const Master = getContext().destination;\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport function getDestination() {\n    return getContext().destination;\n}\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport const Listener = getContext().listener;\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport function getListener() {\n    return getContext().listener;\n}\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * See [[Draw]]\n * @category Core\n */\nexport const Draw = getContext().draw;\n/**\n * Get the singleton attached to the global context.\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * See [[Draw]]\n * @category Core\n */\nexport function getDraw() {\n    return getContext().draw;\n}\n/**\n * A reference to the global context\n * See [[Context]]\n */\nexport const context = getContext();\n/**\n * Promise which resolves when all of the loading promises are resolved.\n * Alias for static [[ToneAudioBuffer.loaded]] method.\n * @category Core\n */\nexport function loaded() {\n    return ToneAudioBuffer.loaded();\n}\n// this fills in name changes from 13.x to 14.x\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource\";\nexport const Buffer = ToneAudioBuffer;\nexport const Buffers = ToneAudioBuffers;\nexport const BufferSource = ToneBufferSource;\n//# sourceMappingURL=index.js.map","import {\n  Oscillator, Noise, Loop, Transport,\n  now as toneNow\n} from 'tone';\n\nexport class PCode {\n  constructor(options) {\n    this.freq = 440;\n    this.sine = new Oscillator(this.freq, 'sine').toDestination();\n    this.saw = new Oscillator(this.freq, 'sawtooth').toDestination();\n    this.tri = new Oscillator(this.freq, 'triangle').toDestination();\n    this.square = new Oscillator(this.freq, 'square').toDestination();\n    this.noise = new Noise('white').toDestination();\n    this.limitHigh = this.sine.frequency.maxValue;\n    this.limitLow = this.sine.frequency.minValue;\n\n    this.pointer = 0;\n    this.tokens = [];\n\n    this.isPlaying = false;\n    this.doLoop = false;\n    this.looper = false;\n    this.lastEvaluateTime = 0;\n    this.currentVolume = -1;\n\n    const {\n      loopContext = 'external',\n      interval = (1 / 30),\n      defaultVolume = -1,\n      comment = {},\n      meta = {}\n    } = (options ? options : {});\n\n    const {\n      enable: enableCommentSyntax = false,\n      line: lineComment = '#',\n      block: blockComment = /\"\"\".*?\"\"\"/g,\n    } = (comment ? comment : {});\n\n    const {\n      enable: enableMetaSyntax = false,\n      code: metaCode = '$',\n    } = (meta ? meta : {});\n\n    Object.assign(\n      this, {\n        loopContext, interval,\n        enableCommentSyntax, lineComment, blockComment,\n        enableMetaSyntax, metaCode\n      }\n    );\n\n    if (this.loopContext == 'internal' && !this.looper) {\n      this.interval = Math.max((1 / 30), this.interval);\n      this.looper = new Loop(_ => {\n        this.internalLoop();\n      }, this.interval);\n      this.looper.context.lookAhead = this.interval;\n      this.looper.start(0);\n      Transport.start();\n\n      console.info('p-code is running with internal loop (via Tone.js Transport)', this.looper);\n    }\n\n    this.currentVolume = defaultVolume;\n    for (let el of [this.sine, this.saw, this.tri, this.square, this.noise]) {\n      el.volume.value = this.currentVolume;\n    }\n\n    if (this.enableCommentSyntax) {\n      console.info(`enabled comment syntax, < ${this.lineComment} > and < ${this.blockComment} >`);\n    }\n\n    if (this.enableMetaSyntax) {\n      console.info(`enabled meta command syntax, < ${this.metaCode} >`);\n    }\n  }\n\n  unpack(code) {\n    this.pointer = 0;\n    let result = '';\n    let start = 0;\n    let end = 0;\n    let stack = 0;\n\n    let peek = () => {\n      return code[this.pointer];\n    };\n\n    let consume = () => {\n      this.pointer++;\n    };\n\n    while(this.pointer < code.length) {\n      let t = peek();\n      if (t == \"<\") {\n        if (stack == 0) {\n          start = this.pointer;\n        }\n        stack++;\n      } else if (t == \">\") {\n        end = this.pointer;\n        stack--;\n        if (stack == 0) {\n          result += code.slice(start+1, end).repeat(2);\n        }\n      } else {\n        if (stack == 0) {\n          result += t;\n        }\n      }\n      consume();\n    }\n\n    return result;\n  }\n\n  next() {\n    this.pointer++;\n  }\n\n  hasNext() {\n    return this.pointer < this.tokens.length;\n  }\n\n  parse(l) {\n    this.pointer = 0;\n    this.tokens = [];\n    if (l) {\n      for(let i=0; i<l.length; i++) {\n        if (isNaN(l[i])) {\n          let chars = l[i].split('');\n          for(let j=0; j<chars.length; j++) {\n            this.tokens.push(chars[j]);\n          }\n        } else {\n          this.tokens.push(l[i]);\n        }\n      }\n    }\n\n    //! TODO;\n    console.info(\n      `parsed length: ${this.tokens.length}\\r\\n`,\n      `- duration[sec/@30fps]: ${this.tokens.length / 30}\\r\\n`,\n      `- duration[min/@30fps]: ${this.tokens.length / 30 / 60}`,\n    );\n    // --\n  }\n\n  run(code) {\n    if (this.enableCommentSyntax) {\n      if (code.indexOf(this.lineComment) == 0) {\n        return;\n      }\n\n      code = code.replace(this.blockComment, '');\n    }\n\n    if (this.enableMetaSyntax) {\n      if (code.indexOf(this.metaCode) == 0) {\n        return;\n      }\n    }\n\n    this.isPlaying = true;\n\n    this.unpack(code);\n\n    let repeatCounter = 0;\n    for(let i=0; i<code.length; i++) {\n      if (code[i] == '<') {\n        repeatCounter++;\n      }\n      if (code[i] == '>') {\n        repeatCounter--;\n      }\n    }\n\n    if (repeatCounter > 0) {\n      for(let i=0; i<repeatCounter; i++) {\n        code += '>';\n      }\n    }\n\n    while(code.indexOf('<') > -1) {\n      code = this.unpack(code);\n    }\n\n    let lex = code.match(/(\\D+)|[+-]?(\\d*[.])?\\d+/gi);\n    this.parse(lex);\n\n    this.lastEvaluateTime = toneNow();\n  }\n\n  execute(t) {\n    if (t != this.prevChar) {\n      if (isNaN(t)) {\n        try {\n          switch (t) {\n          case '~':\n            this.sine.start(this.looper ? this.interval : 0);\n            break;\n          case 'N':\n            this.saw.start(this.looper ? this.interval : 0);\n            break;\n          case '^':\n            this.tri.start(this.looper ? this.interval : 0);\n            break;\n          case '[':\n            this.square.start(this.looper ? this.interval : 0);\n            break;\n          case '=':\n            this.sine.stop(0);\n            this.saw.stop(0);\n            this.tri.stop(0);\n            this.square.stop(0);\n            this.noise.stop(0);\n            break;\n          case '+':\n          case '-':\n          case '*':\n          case '/':\n          case '<':\n          case '>':\n            break;\n          default:\n            this.noise.start(this.looper ? this.interval : 0);\n          }\n        } catch(err) {\n          console.error(err);\n        }\n      } else {\n        if (this.prevChar == '+') {\n          this.freq += parseFloat(t);\n        } else if (this.prevChar == '-') {\n          this.freq -= parseFloat(t);\n        } else if (this.prevChar == '*') {\n          this.freq *= parseFloat(t);\n        } else if (this.prevChar == '/') {\n          this.freq /= parseFloat(t);\n        } else {\n          this.freq = parseFloat(t);\n        }\n\n        if (!isNaN(this.freq)) {\n          //! NOTE: Clamp frequency,\n          //! because outside of [Tone.Signal<\"frequency\">.minValue to Tone.Signal<\"frequency\">.maxValue] range crash Tone.js\n          this.freq = Math.min(Math.max(this.limitLow, this.freq), this.limitHigh);\n          // --\n          this.sine.frequency.value = this.freq;\n          this.saw.frequency.value = this.freq;\n          this.tri.frequency.value = this.freq;\n          this.square.frequency.value = this.freq;\n        }\n      }\n    }\n    this.prevChar = t;\n  }\n\n  stop() {\n    if (this.sine.state == 'started') {\n      this.sine.stop(0);\n    }\n\n    if (this.saw.state == 'started') {\n      this.saw.stop(0);\n    }\n\n    if (this.tri.state == 'started') {\n      this.tri.stop(0);\n    }\n\n    if (this.square.state == 'started') {\n      this.square.stop(0);\n    }\n\n    if (this.noise.state == 'started') {\n      this.noise.stop(0);\n    }\n\n    this.prevChar = '';\n    this.isPlaying = false;\n  }\n\n  reset() {\n    this.pointer = 0;\n  }\n\n  internalLoop() {\n    if (this.isPlaying) {\n      if (this.hasNext()) {\n        let node = this.tokens[this.pointer];\n        this.execute(node);\n        this.next();\n      } else {\n        this.isPlaying = false;\n      }\n    } else {\n      if (this.doLoop) {\n        this.reset();\n        this.isPlaying = true;\n      } else {\n        this.stop();\n      }\n    }\n  }\n\n  setVolume(v) {\n    for (let el of [this.sine, this.saw, this.tri, this.square, this.noise]) {\n      el.volume.value = v;\n    }\n    this.currentVolume = v;\n  }\n}\n"],"sourceRoot":""}